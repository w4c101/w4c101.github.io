<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>w4c101</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/w4c101/"/>
  <updated>2016-06-24T10:32:50.779Z</updated>
  <id>https://github.com/w4c101/</id>
  
  <author>
    <name>w4c101</name>
    <email>perry.du.cn@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《分布式任务调度平台xxl-job》</title>
    <link href="https://github.com/w4c101/2016/06/24/xueli/xxl-job/"/>
    <id>https://github.com/w4c101/2016/06/24/xueli/xxl-job/</id>
    <published>2016-06-24T10:27:41.000Z</published>
    <updated>2016-06-24T10:32:50.779Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;XXL-JOB是一个轻量级分布式任务调度框架，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。现已开放源代码并接入多家公司线上产品线，开箱即用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;u4E00__u7B80_u4ECB&quot;&gt;&lt;a href=&quot;#u4E00__u7B80_u4ECB&quot; class=&quot;headerlink&quot; title=&quot;一 简介&quot;&gt;&lt;/a&gt;一 简介&lt;/h2&gt;&lt;h4 id=&quot;1-1__u4E0B_u8F7D&quot;&gt;&lt;a href=&quot;#1-1__u4E0B_u8F7D&quot; class=&quot;headerlink&quot; title=&quot;1.1 下载&quot;&gt;&lt;/a&gt;1.1 下载&lt;/h4&gt;&lt;p&gt;源码地址&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;github地址：&lt;a href=&quot;https://github.com/xuxueli/xxl-job&quot;&gt;https://github.com/xuxueli/xxl-job&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;git.osc地址：&lt;a href=&quot;http://git.oschina.net/xuxueli0323/xxl-job&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://git.oschina.net/xuxueli0323/xxl-job&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;我将会在两个git仓库同步发布最新代码；用户手册放置在源码“/doc”目录下（ &lt;a href=&quot;https://github.com/xuxueli/xxl-job/tree/master/doc&quot;&gt;https://github.com/xuxueli/xxl-job/tree/master/doc&lt;/a&gt; ）；开箱即用；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;博客地址&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;oschina地址：&lt;a href=&quot;http://my.oschina.net/xuxueli/blog/690978&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://my.oschina.net/xuxueli/blog/690978&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;cnblogs地址：&lt;a href=&quot;http://www.cnblogs.com/xuxueli/p/5021979.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/xuxueli/p/5021979.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;csdn地址：&lt;a href=&quot;http://blog.csdn.net/xuxueli0323/article/details/51674330&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/xuxueli0323/article/details/51674330&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;技术交流群(仅作技术交流)：367260654    &lt;a href=&quot;http://shang.qq.com/wpa/qunwpa?idkey=4686e3fe01118445c75673a66b4cc6b2c7ce0641528205b6f403c179062b0a52&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;http://pub.idqqimg.com/wpa/images/group.png&quot; alt=&quot;image&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;1-2__u7279_u6027&quot;&gt;&lt;a href=&quot;#1-2__u7279_u6027&quot; class=&quot;headerlink&quot; title=&quot;1.2 特性&quot;&gt;&lt;/a&gt;1.2 特性&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;1、简单：支持通过Web页面对任务进行CRUD操作，操作简单，一分钟上手；&lt;/li&gt;
&lt;li&gt;2、动态：支持动态修改任务状态、暂停/恢复任务，以及终止运行中任务，即时生效；&lt;/li&gt;
&lt;li&gt;3、调度HA：“调度中心”基于集群Quartz实现，可保证调度中心HA；&lt;/li&gt;
&lt;li&gt;4、任务HA：任务支持多地址配置，可保证任务HA（Failover）；&lt;/li&gt;
&lt;li&gt;5、一致性：“调度中心”通过DB锁保证集群分布式调度的一致性；&lt;/li&gt;
&lt;li&gt;6、自定义任务参数：支持在线配置调度任务入参，即时生效；&lt;/li&gt;
&lt;li&gt;7、调度线程池：调度系统多线程触发调度运行，确保调度精确执行，不被堵塞；&lt;/li&gt;
&lt;li&gt;8、执行日志：支持在线查看调度结果，并且查看完整的执行日志；&lt;/li&gt;
&lt;li&gt;9、邮件报警：任务失败时支持邮件报警，同时可自定义失败次数阀值；&lt;/li&gt;
&lt;li&gt;10、支持登录验证；&lt;/li&gt;
&lt;li&gt;11、GLUE：提供Web IDE，支持在线开发任务逻辑代码，动态发布，实时编译生效，省略部署上线的过程。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;1-3__u53D1_u5C55&quot;&gt;&lt;a href=&quot;#1-3__u53D1_u5C55&quot; class=&quot;headerlink&quot; title=&quot;1.3 发展&quot;&gt;&lt;/a&gt;1.3 发展&lt;/h4&gt;&lt;p&gt;于2015年中，我在github上创建XXL-JOB项目仓库并提交第一个commit，随之进行系统结构设计，UI选型，交互设计……&lt;/p&gt;
&lt;p&gt;于2015-11月，XXL-JOB终于REALEASE了第一个大版本V1.0， 随后我将之发布到OSCHINA，XXL-JOB在OSCHINA上获得了@红薯的热门推荐，同期分别达到了OSCHINA的“热门动弹”排行第一和git.oschina的开源软件月热度排行第一，在此特别感谢红薯，感谢大家的关注和支持。&lt;/p&gt;
&lt;p&gt;于2015-12月，我将XXL-JOB发表到我司内部知识库，并且得到内部同事认可。&lt;/p&gt;
&lt;p&gt;于2016-01月我司展开XXL-JOB的内部接入和定制工作，在此感谢袁某和尹某两位同事的贡献，同时也感谢内部其他给与关注与支持的同事。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我司大众点评目前已接入XXL-JOB，内部别名《Ferrari》（Ferrari基于XXL-JOB的V1.1版本定制而成，新接入应用推荐升级最新版本V1.3）&lt;/strong&gt;。自2016-01-21接入至2016-05-20为止进行统计，该系统已调度40000余次，表现优异。新接入应用推荐使用最新版本V1.3，因为经过两个大版本的更新，系统的任务模型、UI交互模型以及底层调度通讯模型都有了较大的提升，核心功能更加稳定高效。&lt;/p&gt;
&lt;p&gt;至今，XXL-JOB已接入多家公司的线上产品线，接入场景如电商业务，O2O业务和大数据作业等，截止2016-05-20为止，XXL-JOB已接入的公司包括不限于：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- 1、大众点评；
- 2、山东学而网络科技有限公司；
- 3、安徽慧通互联科技有限公司；
- 4、人人聚财金服；
- 5、上海棠棣信息科技股份有限公司
- ……
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;欢迎大家的关注和使用，XXL-JOB也将拥抱变化，持续发展。&lt;/p&gt;
&lt;h4 id=&quot;1-4__u63A5_u5165_u767B_u8BB0&quot;&gt;&lt;a href=&quot;#1-4__u63A5_u5165_u767B_u8BB0&quot; class=&quot;headerlink&quot; title=&quot;1.4 接入登记&quot;&gt;&lt;/a&gt;1.4 接入登记&lt;/h4&gt;&lt;p&gt;更多接入公司，欢迎在&lt;a href=&quot;https://github.com/xuxueli/xxl-job/issues/1&quot;&gt;https://github.com/xuxueli/xxl-job/issues/1&lt;/a&gt; 登记。&lt;/p&gt;
&lt;h4 id=&quot;1-5__u62A5_u544A_u95EE_u9898&quot;&gt;&lt;a href=&quot;#1-5__u62A5_u544A_u95EE_u9898&quot; class=&quot;headerlink&quot; title=&quot;1.5 报告问题&quot;&gt;&lt;/a&gt;1.5 报告问题&lt;/h4&gt;&lt;p&gt;XXL-JOB托管在Github上，如有问题可在ISSUES上提问，也可以加入技术交流群(仅作技术交流)：367260654 。&lt;/p&gt;
&lt;h4 id=&quot;1-6__u6E90_u7801_u76EE_u5F55_u8BF4_u660E&quot;&gt;&lt;a href=&quot;#1-6__u6E90_u7801_u76EE_u5F55_u8BF4_u660E&quot; class=&quot;headerlink&quot; title=&quot;1.6 源码目录说明&quot;&gt;&lt;/a&gt;1.6 源码目录说明&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;/xxl-job-admin                    【调度中心】：负责管理调度信息，按照调度配置发出调度请求；&lt;/li&gt;
&lt;li&gt;/xxl-job-core                    公共依赖&lt;/li&gt;
&lt;li&gt;/xxl-job-executor-example    【执行器】：负责接收调度请求并执行任务逻辑；&lt;/li&gt;
&lt;li&gt;/db        建表脚本&lt;/li&gt;
&lt;li&gt;/doc    用户手册&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;u4E8C__u603B_u4F53_u8BBE_u8BA1&quot;&gt;&lt;a href=&quot;#u4E8C__u603B_u4F53_u8BBE_u8BA1&quot; class=&quot;headerlink&quot; title=&quot;二 总体设计&quot;&gt;&lt;/a&gt;二 总体设计&lt;/h2&gt;&lt;h4 id=&quot;2-1__u67B6_u6784_u56FE&quot;&gt;&lt;a href=&quot;#2-1__u67B6_u6784_u56FE&quot; class=&quot;headerlink&quot; title=&quot;2.1 架构图&quot;&gt;&lt;/a&gt;2.1 架构图&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/img/201606/14125314_NHk8.png&quot; alt=&quot;XXL-JOB架构图&quot; title=&quot;XXL-JOB架构图&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;2-2__u8BBE_u8BA1_u601D_u60F3&quot;&gt;&lt;a href=&quot;#2-2__u8BBE_u8BA1_u601D_u60F3&quot; class=&quot;headerlink&quot; title=&quot;2.2 设计思想&quot;&gt;&lt;/a&gt;2.2 设计思想&lt;/h4&gt;&lt;p&gt;将调度行为抽象形成“调度中心”公共平台，而平台自身并不承担业务逻辑，“调度中心”负责发起调度请求。&lt;/p&gt;
&lt;p&gt;将任务抽象成分散的JobHandler，交由“执行器”统一管理，“执行器”负责接收调度请求并执行对应的JobHandler中业务逻辑。&lt;/p&gt;
&lt;p&gt;因此，“调度”和“任务”两部分可以相互解耦，提高系统整体稳定性和扩展性；&lt;/p&gt;
&lt;h4 id=&quot;2-3__u7CFB_u7EDF_u7EC4_u6210&quot;&gt;&lt;a href=&quot;#2-3__u7CFB_u7EDF_u7EC4_u6210&quot; class=&quot;headerlink&quot; title=&quot;2.3 系统组成&quot;&gt;&lt;/a&gt;2.3 系统组成&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;调度模块（调度中心）&lt;/strong&gt;：负责管理调度信息，按照调度配置发出调度请求，自身不承担业务代码。调度系统与任务解耦，提高了系统可用性和稳定性，同时调度系统性能不再受限于任务模块；&lt;/p&gt;
&lt;p&gt;支持可视化、简单且动态的维管理调度信息，包括任务新建，更新，删除，GLUE开发和任务报警等，所有上述操作都会实时生效，同时支持监控调度结果以及执行日志，支持执行器Failover。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;执行模块（执行器）&lt;/strong&gt;：负责接收调度请求并执行任务逻辑。任务模块专注于任务的执行等操作，开发和维护更加简单和高效；&lt;/p&gt;
&lt;p&gt;支持接收“调度中心”的执行请求、终止请求和日志请求等。&lt;/p&gt;
&lt;h2 id=&quot;u4E09__u5B9E_u73B0_u539F_u7406&quot;&gt;&lt;a href=&quot;#u4E09__u5B9E_u73B0_u539F_u7406&quot; class=&quot;headerlink&quot; title=&quot;三 实现原理&quot;&gt;&lt;/a&gt;三 实现原理&lt;/h2&gt;&lt;h4 id=&quot;3-1_quartz_u7684_u4E0D_u8DB3&quot;&gt;&lt;a href=&quot;#3-1_quartz_u7684_u4E0D_u8DB3&quot; class=&quot;headerlink&quot; title=&quot;3.1 quartz的不足&quot;&gt;&lt;/a&gt;3.1 quartz的不足&lt;/h4&gt;&lt;p&gt;Quartz作为开源作业调度中的佼佼者，是作业调度的首选。但是集群环境中Quartz采用API的方式对任务进行管理，从而可以避免上述问题，但是同样存在以下问题：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- 问题一：调用API的的方式操作任务，不人性化；
- 问题二：需要持久化业务QuartzJobBean到底层数据表中，系统侵入性相当严重。
- 问题三：调度逻辑和QuartzJobBean耦合在同一个项目中，这将导致一个问题，在调度任务数量逐渐增多，同时调度任务逻辑逐渐加重的情况加，此时调度系统的性能将大大受限于业务；
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;XXL-JOB的调度中心基于Quartz实现，弥补了quartz的上述不足之处。&lt;/p&gt;
&lt;h4 id=&quot;3-2_RemoteHttpJobBean&quot;&gt;&lt;a href=&quot;#3-2_RemoteHttpJobBean&quot; class=&quot;headerlink&quot; title=&quot;3.2 RemoteHttpJobBean&quot;&gt;&lt;/a&gt;3.2 RemoteHttpJobBean&lt;/h4&gt;&lt;p&gt;常规Quartz的开发，任务逻辑一般维护在QuartzJobBean中，耦合很严重。XXL-JOB中“调度模块”和“任务模块”完全解耦，调度模块中的所有调度任务使用同一个QuartzJobBean，即RemoteHttpJobBean。不同的调度任务将各自参数维护在各自扩展表数据中，当触发RemoteHttpJobBean执行时，将会解析不同的任务参数发起远程调用，调用各自的远程执行器服务。这种调用模型类似RPC调用，RemoteHttpJobBean提供调用代理的功能，而执行器提供远程服务的功能。&lt;/p&gt;
&lt;h4 id=&quot;3-3__u8C03_u5EA6_u4E2D_u5FC3HA_uFF08_u96C6_u7FA4_uFF09&quot;&gt;&lt;a href=&quot;#3-3__u8C03_u5EA6_u4E2D_u5FC3HA_uFF08_u96C6_u7FA4_uFF09&quot; class=&quot;headerlink&quot; title=&quot;3.3 调度中心HA（集群）&quot;&gt;&lt;/a&gt;3.3 调度中心HA（集群）&lt;/h4&gt;&lt;p&gt;基于Quartz的集群方案，数据库选用Mysql；集群分布式并发环境中使用QUARTZ定时任务调度，会在各个节点会上报任务，存到数据库中，执行时会从数据库中取出触发器来执行，如果触发器的名称和执行时间相同，则只有一个节点去执行此任务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/img/201606/14125524_GxS9.png&quot; alt=&quot;输入图片说明&quot; title=&quot;在这里输入图片标题&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;3-4__u8C03_u5EA6_u7EBF_u7A0B_u6C60&quot;&gt;&lt;a href=&quot;#3-4__u8C03_u5EA6_u7EBF_u7A0B_u6C60&quot; class=&quot;headerlink&quot; title=&quot;3.4 调度线程池&quot;&gt;&lt;/a&gt;3.4 调度线程池&lt;/h4&gt;&lt;p&gt;默认线程池中线程的数量为10个，避免单线程因阻塞而引起任务调度延迟。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/img/201606/14125549_0Knr.png&quot; alt=&quot;输入图片说明&quot; title=&quot;在这里输入图片标题&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;3-5_@DisallowConcurrentExecution&quot;&gt;&lt;a href=&quot;#3-5_@DisallowConcurrentExecution&quot; class=&quot;headerlink&quot; title=&quot;3.5 @DisallowConcurrentExecution&quot;&gt;&lt;/a&gt;3.5 @DisallowConcurrentExecution&lt;/h4&gt;&lt;p&gt;XXL-JOB调度模块的“调度中心”默认不使用该注解，即默认开启并行机制，因为RemoteHttpJobBean为公共QuartzJobBean，这样在多线程调度的情况下，调度模块被阻塞的几率很低，大大提高了调度系统的承载量。&lt;/p&gt;
&lt;p&gt;XXL-JOB的每个调度任务虽然在调度模块是并行调度执行的，但是任务调度传递到任务模块的“执行器”确实串行执行的，同时支持任务终止。&lt;/p&gt;
&lt;h4 id=&quot;3-6__u65E5_u5FD7_u56DE_u8C03_u670D_u52A1&quot;&gt;&lt;a href=&quot;#3-6__u65E5_u5FD7_u56DE_u8C03_u670D_u52A1&quot; class=&quot;headerlink&quot; title=&quot;3.6 日志回调服务&quot;&gt;&lt;/a&gt;3.6 日志回调服务&lt;/h4&gt;&lt;p&gt;调度模块的“调度中心”作为Web服务单独部署，除此之外，内部嵌入jetty服务器提供日志回调服务。&lt;/p&gt;
&lt;p&gt;“执行器”在接收到任务执行请求后，执行任务，在执行结束之后会将执行结果回调通知“调度中心”，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/img/201606/14125628_qON8.png&quot; alt=&quot;输入图片说明&quot; title=&quot;在这里输入图片标题&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;3-7__u4EFB_u52A1HA_uFF08Failover_uFF09&quot;&gt;&lt;a href=&quot;#3-7__u4EFB_u52A1HA_uFF08Failover_uFF09&quot; class=&quot;headerlink&quot; title=&quot;3.7 任务HA（Failover）&quot;&gt;&lt;/a&gt;3.7 任务HA（Failover）&lt;/h4&gt;&lt;p&gt;如下图所示，任务“执行器地址”支持配置多个，用逗号分隔，如“127.0.0.1:9998,127.0.0.1:9999”。如果任务配置多个执行器地址，当调度中心每次发起调度请求时，会按照地址配置的顺序依次对执行器发出心跳检测请求，第一个检测为存活状态的执行器将会被选定。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/img/201606/14125648_7kTR.png&quot; alt=&quot;输入图片说明&quot; title=&quot;在这里输入图片标题&quot;&gt;&lt;/p&gt;
&lt;p&gt;调度成功后，可在日志监控界面查看执行日志；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/img/201606/14125703_xKWj.png&quot; alt=&quot;输入图片说明&quot; title=&quot;在这里输入图片标题&quot;&gt;&lt;/p&gt;
&lt;p&gt;调度日志显示，任务配置的地址“227.0.0.1:9999,127.0.0.1:9999”，首先对第一个执行器地址“227.0.0.1:9999”进行心跳检测，心跳失败因此跳过；然后对第二个执行器地址“127.0.0.1:9999”进行心跳检测，心跳检测成功，选定为“目标执行器”；然后对“目标执行器”发送调度请求，调度流程结束，等待执行器回调执行结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/img/201606/14125738_xpGk.png&quot; alt=&quot;输入图片说明&quot; title=&quot;在这里输入图片标题&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;3-8__u8C03_u5EA6_u65E5_u5FD7_u7EC4_u6210&quot;&gt;&lt;a href=&quot;#3-8__u8C03_u5EA6_u65E5_u5FD7_u7EC4_u6210&quot; class=&quot;headerlink&quot; title=&quot;3.8 调度日志组成&quot;&gt;&lt;/a&gt;3.8 调度日志组成&lt;/h4&gt;&lt;p&gt;调度中心每次进行任务调度，都会记录一条任务日志，任务日志主要包括以下三部分内容：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- A、任务信息：包括“执行器地址”、“JobHandler”和“执行参数”等属性，根据这些参数，可以精确的定位任务执行的具体机器和任务代码；
- B、调度信息：包括“调度时间”、“调度结果”和“调度日志”等，根据这些参数，可以了解“调度中心”发起调度请求时具体情况。
- C、执行信息：包括“执行时间”、“执行结果”和“执行日志”等，根据这些参数，可以了解在“执行器”端任务执行的具体情况；
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/img/201606/14125801_9yfn.png&quot; alt=&quot;输入图片说明&quot; title=&quot;在这里输入图片标题&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;3-9_Bean_u6A21_u5F0F_u4EFB_u52A1&quot;&gt;&lt;a href=&quot;#3-9_Bean_u6A21_u5F0F_u4EFB_u52A1&quot; class=&quot;headerlink&quot; title=&quot;3.9 Bean模式任务&quot;&gt;&lt;/a&gt;3.9 Bean模式任务&lt;/h4&gt;&lt;p&gt;开发步骤：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- 1、开发一个继承“IJobHandler”的实现类，任务逻辑写在execute方法中；
- 2、将任务类装配到Spring中，例如加 “@Service” 注解；
- 3、在任务类上加 “@JobHander” 注解，定义注解的name属性值；
（步骤3中定义的name属性值，在配置Bean模式任务时会用到）
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;原理：&lt;br&gt;    每个Bean模式任务都是一个Spring的Bean类实例，它被维护在“执行器”项目的Spring容器中。任务类需要加“@JobHander(name=”名称”)”注解，因为“执行器”会根据该注解识别Spring容器中的任务。任务类需要继承统一接口“IJobHandler”，任务逻辑在execute方法中开发，因为“执行器”在接收到调度中心的调度请求时，将会调用“IJobHandler”的execute方法，执行任务逻辑。&lt;/p&gt;
&lt;h4 id=&quot;3-10_GLUE_u6A21_u5F0F_u4EFB_u52A1&quot;&gt;&lt;a href=&quot;#3-10_GLUE_u6A21_u5F0F_u4EFB_u52A1&quot; class=&quot;headerlink&quot; title=&quot;3.10 GLUE模式任务&quot;&gt;&lt;/a&gt;3.10 GLUE模式任务&lt;/h4&gt;&lt;p&gt;开发步骤：GLUE模式任务的开发步骤比较简单，进入GLUE编辑界面，在Demo任务代码的execute方法中写入任务逻辑即可；可使用@Resource或@Autoward注解注入“执行器”项目中的Spring服务；&lt;/p&gt;
&lt;p&gt;原理：每个Glue任务的代码，实际上是“一个继承自“IJobHandler”的实现类的类代码”，“执行器”接收到“调度中心”的调度请求时，会通过Groovy类加载器加载此代码，实例化成Java对象，同时注入此代码中声明的Spring服务（请确保Glue代码中的服务和类引用在“执行器”项目中存在），然后调用该对象的execute方法，执行任务逻辑。&lt;/p&gt;
&lt;h4 id=&quot;3-11__u6267_u884C_u5668&quot;&gt;&lt;a href=&quot;#3-11__u6267_u884C_u5668&quot; class=&quot;headerlink&quot; title=&quot;3.11 执行器&quot;&gt;&lt;/a&gt;3.11 执行器&lt;/h4&gt;&lt;p&gt;执行器实际上是一个内嵌的Jetty服务器，默认端口9999。&lt;/p&gt;
&lt;p&gt;在项目启动时，执行器会通过“@JobHander”识别Spring容器中“Bean模式任务”，以注解的name属性为key管理起来。&lt;/p&gt;
&lt;p&gt;“执行器”接收到“调度中心”的调度请求时，如果任务类型为“Bean模式”，将会匹配Spring容器中的“Bean模式任务”，然后调用其execute方法，执行任务逻辑。如果任务类型为“GLUE模式”，将会加载GLue代码，实例化Java对象，注入依赖的Spring服务（注意：Glue代码中注入的Spring服务，必须存在与该“执行器”项目的Spring容器中），然后调用execute方法，执行任务逻辑。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/img/201606/14125907_Eajh.png&quot; alt=&quot;输入图片说明&quot; title=&quot;在这里输入图片标题&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;3-12__u4EFB_u52A1_u65E5_u5FD7&quot;&gt;&lt;a href=&quot;#3-12__u4EFB_u52A1_u65E5_u5FD7&quot; class=&quot;headerlink&quot; title=&quot;3.12 任务日志&quot;&gt;&lt;/a&gt;3.12 任务日志&lt;/h4&gt;&lt;p&gt;XXL-JOB会为每次调度请求生成一个单独的日志文件，通过重写LOG4J的Appender实现如下图的数据1处，“调度中心”查看执行日志时将会加载对应的日志文件。&lt;/p&gt;
&lt;p&gt;需要注意的是，“执行器”中日志Appender上配置的包名（如下图数据3处），需要覆盖到所有任务（Bean模式 + GLUE模式）的包名，否则覆盖不到的任务将不会生成日志文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/img/201606/14125931_Digy.png&quot; alt=&quot;输入图片说明&quot; title=&quot;在这里输入图片标题&quot;&gt;&lt;/p&gt;
&lt;p&gt;单独日志文件存放的位置可在“执行器”的log.xml文件进行自定义，如上图中的数字2的位置所示，默认位置为项目磁盘根目录下“/logs/xxl-job/”；&lt;/p&gt;
&lt;p&gt;目录格式为：/logs/xxl-job/ “格式化日期”/“数据库调度日志记录的主键ID . log”。&lt;/p&gt;
&lt;h4 id=&quot;3-13__u7CFB_u7EDF_u622A_u56FE&quot;&gt;&lt;a href=&quot;#3-13__u7CFB_u7EDF_u622A_u56FE&quot; class=&quot;headerlink&quot; title=&quot;3.13 系统截图&quot;&gt;&lt;/a&gt;3.13 系统截图&lt;/h4&gt;&lt;p&gt;登陆截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/img/201606/14125958_3lh1.png&quot; alt=&quot;输入图片说明&quot; title=&quot;在这里输入图片标题&quot;&gt;&lt;/p&gt;
&lt;p&gt;任务列表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/img/201606/14130011_B19K.png&quot; alt=&quot;输入图片说明&quot; title=&quot;在这里输入图片标题&quot;&gt;&lt;/p&gt;
&lt;p&gt;任务配置截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/img/201606/14130021_CeGE.png&quot; alt=&quot;输入图片说明&quot; title=&quot;在这里输入图片标题&quot;&gt;&lt;/p&gt;
&lt;p&gt;在线开发任务GLUE代码，Wed IDE截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/img/201606/14130036_tZPO.png&quot; alt=&quot;输入图片说明&quot; title=&quot;在这里输入图片标题&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;u56DB__u7248_u672C_u66F4_u65B0&quot;&gt;&lt;a href=&quot;#u56DB__u7248_u672C_u66F4_u65B0&quot; class=&quot;headerlink&quot; title=&quot;四 版本更新&quot;&gt;&lt;/a&gt;四 版本更新&lt;/h2&gt;&lt;h4 id=&quot;4-1__u7248_u672C_V1-1-x_uFF0C_u65B0_u7279_u6027&quot;&gt;&lt;a href=&quot;#4-1__u7248_u672C_V1-1-x_uFF0C_u65B0_u7279_u6027&quot; class=&quot;headerlink&quot; title=&quot;4.1 版本 V1.1.x，新特性&quot;&gt;&lt;/a&gt;4.1 版本 V1.1.x，新特性&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;【于V1.1.x版本，XXL-JOB正式应用于我司，内部定制别名为 “Ferrari”，新接入应用推荐使用最新版本V1.3.x】&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1、简单：支持通过Web页面对任务进行CRUD操作，操作简单，一分钟上手；&lt;/li&gt;
&lt;li&gt;2、动态：支持动态修改任务状态，动态暂停/恢复任务，即时生效；&lt;/li&gt;
&lt;li&gt;3、服务HA：任务信息持久化到mysql中，Job服务天然支持集群，保证服务HA；&lt;/li&gt;
&lt;li&gt;4、任务HA：某台Job服务挂掉，任务会平滑分配给其他的某一台存活服务，即使所有服务挂掉，重启时或补偿执行丢失任务；&lt;/li&gt;
&lt;li&gt;5、一个任务只会在其中一台服务器上执行；&lt;/li&gt;
&lt;li&gt;6、任务串行执行；&lt;/li&gt;
&lt;li&gt;7、支持自定义参数；&lt;/li&gt;
&lt;li&gt;8、支持远程任务执行终止；&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;4-2__u7248_u672C_V1-2-x_uFF0C_u65B0_u7279_u6027&quot;&gt;&lt;a href=&quot;#4-2__u7248_u672C_V1-2-x_uFF0C_u65B0_u7279_u6027&quot; class=&quot;headerlink&quot; title=&quot;4.2 版本 V1.2.x，新特性&quot;&gt;&lt;/a&gt;4.2 版本 V1.2.x，新特性&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;1、支持任务分组；&lt;/li&gt;
&lt;li&gt;2、支持“本地任务”、“远程任务”；&lt;/li&gt;
&lt;li&gt;3、底层通讯支持两种方式，Servlet方式 + JETTY方式；&lt;/li&gt;
&lt;li&gt;4、支持“任务日志”；&lt;/li&gt;
&lt;li&gt;&lt;p&gt;5、支持“串行执行”，并行执行；&lt;/p&gt;
&lt;p&gt;  说明：V1.2版本将系统架构按功能拆分为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- 调度模块（调度中心）：负责管理调度信息，按照调度配置发出调度请求；
- 执行模块（执行器）：负责接收调度请求并执行任务逻辑；
- 通讯模块：负责调度模块和任务模块之间的信息通讯；
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  优点：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- 解耦：任务模块提供任务接口，调度模块维护调度信息，业务相互独立；
- 高扩展性；
- 稳定性；
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;4-3__u7248_u672C_V1-3-0_uFF0C_u65B0_u7279_u6027&quot;&gt;&lt;a href=&quot;#4-3__u7248_u672C_V1-3-0_uFF0C_u65B0_u7279_u6027&quot; class=&quot;headerlink&quot; title=&quot;4.3 版本 V1.3.0，新特性&quot;&gt;&lt;/a&gt;4.3 版本 V1.3.0，新特性&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;1、遗弃“本地任务”模式，推荐使用“远程任务”，易于系统解耦，任务对应的JobHander统称为“执行器”；&lt;/li&gt;
&lt;li&gt;2、遗弃“servlet”方式底层系统通讯，推荐使用JETTY方式，调度+回调双向通讯，重构通讯逻辑；&lt;/li&gt;
&lt;li&gt;3、UI交互优化：左侧菜单展开状态优化，菜单项选中状态优化，任务列表打开表格有压缩优化；&lt;/li&gt;
&lt;li&gt;&lt;p&gt;4、【重要】“执行器”细分为：BEAN、GLUE两种开发模式，简介见下文：&lt;/p&gt;
&lt;p&gt;  “执行器” 模式简介：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- BEAN模式执行器：每个执行器都是Spring的一个Bean实例，XXL-JOB通过注解@JobHander识别和调度执行器；
 -GLUE模式执行器：每个执行器对应一段代码，在线Web编辑和维护，动态编译生效，执行器负责加载GLUE代码和执行；
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;4-4__u7248_u672C_V1-3-1_uFF0C_u65B0_u7279_u6027&quot;&gt;&lt;a href=&quot;#4-4__u7248_u672C_V1-3-1_uFF0C_u65B0_u7279_u6027&quot; class=&quot;headerlink&quot; title=&quot;4.4 版本 V1.3.1，新特性&quot;&gt;&lt;/a&gt;4.4 版本 V1.3.1，新特性&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;1、更新项目目录结构：&lt;ul&gt;
&lt;li&gt;/xxl-job-admin ——————– 【调度中心】：负责管理调度信息，按照调度配置发出调度请求；&lt;/li&gt;
&lt;li&gt;/xxl-job-core ———————– 公共依赖&lt;/li&gt;
&lt;li&gt;/xxl-job-executor-example —— 【执行器】：负责接收调度请求并执行任务逻辑；&lt;/li&gt;
&lt;li&gt;/db ———————————- 建表脚本&lt;/li&gt;
&lt;li&gt;/doc ——————————— 用户手册&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;2、在新的目录结构上，升级了用户手册；&lt;/li&gt;
&lt;li&gt;3、优化了一些交互和UI；&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;4-5__u7248_u672C_V1-3-2_uFF0C_u65B0_u7279_u6027&quot;&gt;&lt;a href=&quot;#4-5__u7248_u672C_V1-3-2_uFF0C_u65B0_u7279_u6027&quot; class=&quot;headerlink&quot; title=&quot;4.5 版本 V1.3.2，新特性&quot;&gt;&lt;/a&gt;4.5 版本 V1.3.2，新特性&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;1、调度逻辑进行事务包裹；&lt;/li&gt;
&lt;li&gt;2、执行器异步回调执行日志；&lt;/li&gt;
&lt;li&gt;3、【重要】在 “调度中心” 支持HA的基础上，扩展执行器的Failover支持，支持配置多执行期地址；&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;u89C4_u5212_u4E2D&quot;&gt;&lt;a href=&quot;#u89C4_u5212_u4E2D&quot; class=&quot;headerlink&quot; title=&quot;规划中&quot;&gt;&lt;/a&gt;规划中&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;1、任务终止时，任务队列中调度回调通过被终止的接口；&lt;/li&gt;
&lt;li&gt;2、任务执行规则自定义：假如前一个任务正在执行，后续调度执行规则支持自定义；&lt;pre&gt;&lt;code&gt;串行（默认，当前逻辑）：后续调度入调度队列；
并行：后续调度并行执行；
Pass：后续调度被Pass；
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;3、兼容oracle；&lt;/li&gt;
&lt;li&gt;4、任务依赖；&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;XXL-JOB是一个轻量级分布式任务调度框架，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。现已开放源代码并接入多家公司线上产品线，开箱即用。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>基于quartz的云调度中心实现</title>
    <link href="https://github.com/w4c101/2016/05/31/tengkai/quartz/"/>
    <id>https://github.com/w4c101/2016/05/31/tengkai/quartz/</id>
    <published>2016-06-01T03:45:44.000Z</published>
    <updated>2016-06-01T06:27:16.734Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;云调度中心，本身不执行任何业务代码，只负责管理各个任务的调度，进而将调度与任务执行解耦，方便调度中心自身的升级维护。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;u80CC_u666F&quot;&gt;&lt;a href=&quot;#u80CC_u666F&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;作为业务开发人员，会经常需要写一个定时任务。目前，写定时任务应用最广泛最成熟的方案是OpenSymphony开源组织在任务调度领域的一个开源项目quartz，比如要写一个定时数据同步任务，在完成quartz的相关配置后，只需要写一个jobBean_A就能基于quartz完成调度；如果要再开发一个任务，那么再写一个jobBean_B。&lt;/p&gt;
&lt;p&gt;这样做的方式有一个地方不是很好，quartz调度与job业务耦合在一起，当任务数量越来越多，甚至达到成千上万个，对于项目本身的维护也是一个挺大的挑战。这时，会考虑将quartz任务项目拆分出来，但这样每一个任务工程都需要依赖quartz，不方便统一调度管理。为了能&lt;code&gt;统一管理调度任务&lt;/code&gt;，又能将&lt;code&gt;调度和job业务分离&lt;/code&gt;，我们提出&lt;code&gt;云调度方案&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;u67B6_u6784_u8BBE_u8BA1&quot;&gt;&lt;a href=&quot;#u67B6_u6784_u8BBE_u8BA1&quot; class=&quot;headerlink&quot; title=&quot;架构设计&quot;&gt;&lt;/a&gt;架构设计&lt;/h3&gt;&lt;p&gt;云调度中心ferrari的设计目标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调度中心本身不执行任何业务代码，只负责管理各个任务。这样的好处是，调度中心与业务job解耦，方便调度中心自身的升级维护；&lt;/li&gt;
&lt;li&gt;job无需关心调度中心的内部逻辑，只需关注自身的job业务逻辑，让写一个job像写一个web action一样方便。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基于上述初衷，我们提出的云调度中心设计方案，如图：&lt;br&gt;&lt;img src=&quot;https://static.oschina.net/uploads/img/201605/19150048_dmyG.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;总共分为三层：调度控制层，调度接入层，业务层。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;调度控制层，基于quartz实现，主要用于管理任务调度信息，如调度job的类名、方法名、方法入参、job地址、job执行时间等；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;调度接入层，主要用于接收调度控制中心的调度指令（如执行、终止任务命令），并根据接收到的任务信息（类名、方法名、入参）进行反射调用相应的任务类；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;业务层，这里主要用于实现job逻辑；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这样，要开发一个任务，基本不用关心调度控制层和接入层的逻辑，只需在业务层实现任务逻辑即可。任务开发完后，在调度控制中心新增一个调度任务信息，便可接收调度中心的调度。&lt;/p&gt;
&lt;h3 id=&quot;u5B9E_u73B0_u65B9_u6848&quot;&gt;&lt;a href=&quot;#u5B9E_u73B0_u65B9_u6848&quot; class=&quot;headerlink&quot; title=&quot;实现方案&quot;&gt;&lt;/a&gt;实现方案&lt;/h3&gt;&lt;p&gt;云调度中心的实现是基于quartz，所以对quartz必须有个清楚的理解。&lt;/p&gt;
&lt;p&gt;Quartz任务调度的核心元素是scheduler(调度器)，trigger(触发器，用于定义调度时间规则) 和 job(任务)，其中 trigger 和 job 是任务调度的元数据，scheduler 是实际执行调度的控制器。quartz内部的调度原理可以查看后面列举的参考文档，这里具体讲讲使用quartz的几个注意点。&lt;/p&gt;
&lt;h4 id=&quot;u7EBF_u7A0B_u6C60_u914D_u7F6E&quot;&gt;&lt;a href=&quot;#u7EBF_u7A0B_u6C60_u914D_u7F6E&quot; class=&quot;headerlink&quot; title=&quot;线程池配置&quot;&gt;&lt;/a&gt;线程池配置&lt;/h4&gt;&lt;p&gt;quartz.properties里的线程池配置：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#Configure ThreadPool&amp;#10;org.quartz.threadPool.class: org.quartz.simpl.SimpleThreadPool&amp;#10;org.quartz.threadPool.threadCount: 15&amp;#10;org.quartz.threadPool.threadPriority: 5&amp;#10;org.quartz.threadPool.threadsInheritContextClassLoaderOfInitializingThread: true&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Quartz 中自带了一个线程池的实现SimpleThreadPool，并通过threadCount来设置最大并发数，一般设置在10～50比较合适。&lt;/p&gt;
&lt;h4 id=&quot;misfire_u7B56_u7565&quot;&gt;&lt;a href=&quot;#misfire_u7B56_u7565&quot; class=&quot;headerlink&quot; title=&quot;misfire策略&quot;&gt;&lt;/a&gt;misfire策略&lt;/h4&gt;&lt;p&gt;misfire，即错过的，指本来应该被执行但实际没有被执行的任务调度，一般来说引起misfire的情况有以下4种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调度控制中心因为某些原因被重启。在系统关闭到重新启动之间的一段时间里，可能有些任务会被 misfire；&lt;/li&gt;
&lt;li&gt;Trigger 被暂停（suspend）的一段时间里，有些任务可能会被 misfire；&lt;/li&gt;
&lt;li&gt;线程池中所有线程都被占用，导致任务无法被触发执行，造成 misfire；&lt;/li&gt;
&lt;li&gt;有状态任务在下次触发时间到达时，上次执行还没有结束（无状态任务没有这种情况）；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;quartz对misfire的产生有个时间条件，超过这个设定的时间则认为是misfire，配置如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#Misfire&amp;#10;org.quartz.jobStore.misfireThreshold: 120000 #120&amp;#31186;&amp;#10;org.quartz.jobStore.maxMisfiresToHandleAtATime: 1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;为了处理 misfired job，Quartz 中为 trigger 定义了处理策略，主要有下面两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;MISFIRE_INSTRUCTION_FIRE_ONCE_NOW：针对 misfired job 马上执行一次；&lt;/li&gt;
&lt;li&gt;MISFIRE_INSTRUCTION_DO_NOTHING：忽略 misfired job，等待下次触发；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ferrari使用的是第2种策略：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CronScheduleBuilder cronScheduleBuilder = CronScheduleBuilder.cronSchedule(cronExpression).withMisfireHandlingInstructionDoNothing();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;u8C03_u5EA6_u96C6_u7FA4_u8BBE_u7F6E&quot;&gt;&lt;a href=&quot;#u8C03_u5EA6_u96C6_u7FA4_u8BBE_u7F6E&quot; class=&quot;headerlink&quot; title=&quot;调度集群设置&quot;&gt;&lt;/a&gt;调度集群设置&lt;/h4&gt;&lt;p&gt;Quartz 中的 trigger 和 job 需要存储下来才能被使用，有两种存储方式：内存和数据库。如果将调度信息存储在内存，那么只要quartz应用重启，这些信息就会丢失，所以在生产环境中，一般都用数据库存储的方式，配置如下：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#Configure JobStore for RAM&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#org.quartz.jobStore.class: org.quartz.simpl.RAMJobStore&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#for cluster&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;org.quartz.jobStore.tablePrefix = XXX_&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;org.quartz.jobStore.class: org.quartz.impl.jdbcjobstore.JobStoreTX &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;org.quartz.jobStore.isClustered: &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;org.quartz.jobStore.clusterCheckinInterval: &lt;span class=&quot;number&quot;&gt;20000&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;jobStore设置为jdbcjobstore.JobStoreTX即代表数据库存储方式，由于quartz集群是通过数据表来实现并发锁控制，所以需要设置集群的节点检查轮训时间clusterCheckinInterval，这里设置为20s。&lt;/p&gt;
&lt;h4 id=&quot;u8C03_u5EA6_u5668_u914D_u7F6E&quot;&gt;&lt;a href=&quot;#u8C03_u5EA6_u5668_u914D_u7F6E&quot; class=&quot;headerlink&quot; title=&quot;调度器配置&quot;&gt;&lt;/a&gt;调度器配置&lt;/h4&gt;&lt;p&gt;spring对quartz进行了整合，这里采用基于spring的quartz配置，如下：&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&amp;lt;!-- 默认 lazy-init=&quot;false&quot;spring-context-support version: 3.2.14.RELEASE quartz version:2.2.2--&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;bean&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;quartzScheduler&quot;&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;org.springframework.scheduling.quartz.SchedulerFactoryBean&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;property&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;dataSource&quot;&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;ref&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;dataSource&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&amp;lt;!-- 设置自动启动 --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;property&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;autoStartup&quot;&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;true&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&amp;lt;!--必须的，QuartzScheduler 延时启动，应用启动完后 QuartzScheduler 再启动 --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;property&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;startupDelay&quot;&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;20&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&amp;lt;!--需要overwrite已经存在的job，如果需要动态的修改已经存在的job，就需要设置为true，否则会以数据库中已经存在的为准--&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;property&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;overwriteExistingJobs&quot;&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;true&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;property&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;applicationContextSchedulerContextKey&quot;&lt;/span&gt;  &lt;span class=&quot;attribute&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;applicationContextKey&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;property&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;configLocation&quot;&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;classpath:quartz.properties&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;bean&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;quartz_u4EFB_u52A1_u5F00_u53D1&quot;&gt;&lt;a href=&quot;#quartz_u4EFB_u52A1_u5F00_u53D1&quot; class=&quot;headerlink&quot; title=&quot;quartz任务开发&quot;&gt;&lt;/a&gt;quartz任务开发&lt;/h4&gt;&lt;p&gt;基于云调度中心ferrari的架构，在调度控制中心层，我们只要开发一个quartzJobBean。在这个jobBean中，基于ferrari协议将需要执行的类名、方法名、入参、任务机器地址等信息封装成一个request，然后发送请求（ferrari用的是http请求）到任务目标机器。&lt;/p&gt;
&lt;p&gt;在业务层，任务机器接收到调度控制中心的指令，解析出任务信息，便交给任务执行线程池，任务执行线程通过反射调用目标任务类进行执行。作为业务层，无需基于quartz做任何开发，只需开发一个普通的类（称为任务类），然后将任务信息配置到调度控制中心，便可实现调度。&lt;/p&gt;
&lt;h3 id=&quot;ferrari_u63A5_u5165_u8BF4_u660E&quot;&gt;&lt;a href=&quot;#ferrari_u63A5_u5165_u8BF4_u660E&quot; class=&quot;headerlink&quot; title=&quot;ferrari接入说明&quot;&gt;&lt;/a&gt;ferrari接入说明&lt;/h3&gt;&lt;h4 id=&quot;maven_u4F9D_u8D56&quot;&gt;&lt;a href=&quot;#maven_u4F9D_u8D56&quot; class=&quot;headerlink&quot; title=&quot;maven依赖&quot;&gt;&lt;/a&gt;maven依赖&lt;/h4&gt;&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;com.dianping&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;ferrari-core&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;1.2.4&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;web-xml_u914D_u7F6Eservlet_u5165_u53E3&quot;&gt;&lt;a href=&quot;#web-xml_u914D_u7F6Eservlet_u5165_u53E3&quot; class=&quot;headerlink&quot; title=&quot;web.xml配置servlet入口&quot;&gt;&lt;/a&gt;web.xml配置servlet入口&lt;/h4&gt;&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;servlet&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;servlet-name&lt;/span&gt;&amp;gt;&lt;/span&gt;FerrariServlet&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;servlet-name&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;servlet-class&lt;/span&gt;&amp;gt;&lt;/span&gt;com.cip.ferrari.core.FerrariDirectServlet&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;servlet-class&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;load-on-startup&lt;/span&gt;&amp;gt;&lt;/span&gt;1&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;load-on-startup&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;servlet&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;servlet-mapping&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;servlet-name&lt;/span&gt;&amp;gt;&lt;/span&gt;FerrariServlet&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;servlet-name&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;url-pattern&lt;/span&gt;&amp;gt;&lt;/span&gt;/xxx/*&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;url-pattern&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;servlet-mapping&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;u5F00_u59CB_u5199_u4F60_u7684_u4EFB_u52A1_u7C7B_u53CA_u65B9_u6CD5_uFF0C_u7C7B_u540D_u3001_u65B9_u6CD5_u3001_u5165_u53C2_u5728_u65B0_u589E_u4EFB_u52A1_u65F6_u914D_u7F6E&quot;&gt;&lt;a href=&quot;#u5F00_u59CB_u5199_u4F60_u7684_u4EFB_u52A1_u7C7B_u53CA_u65B9_u6CD5_uFF0C_u7C7B_u540D_u3001_u65B9_u6CD5_u3001_u5165_u53C2_u5728_u65B0_u589E_u4EFB_u52A1_u65F6_u914D_u7F6E&quot; class=&quot;headerlink&quot; title=&quot;开始写你的任务类及方法，类名、方法、入参在新增任务时配置&quot;&gt;&lt;/a&gt;开始写你的任务类及方法，类名、方法、入参在新增任务时配置&lt;/h4&gt;&lt;p&gt;ferrari新增任务界面：&lt;br&gt;&lt;img src=&quot;https://static.oschina.net/uploads/img/201605/19152010_9IrQ.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;u4E91_u8C03_u5EA6_u4E2D_u5FC3_u65E5_u5FD7_u63A5_u5165&quot;&gt;&lt;a href=&quot;#u4E91_u8C03_u5EA6_u4E2D_u5FC3_u65E5_u5FD7_u63A5_u5165&quot; class=&quot;headerlink&quot; title=&quot;云调度中心日志接入&quot;&gt;&lt;/a&gt;云调度中心日志接入&lt;/h4&gt;&lt;p&gt;由于job任务不在调度中心执行，而是有另外的job服务机器执行，所以要看业务日志代码，必须登录对应的业务机器。如果job很多，又散落在各个机器，那么要查看job运行日志，效率就会比较低。为了方便日志查看，ferrari提供了日志接入方案，在log4j.xml中增加一个append配置：&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;appender&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;FERRARI&quot;&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;com.cip.ferrari.core.log.FerrariFileAppender&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;param&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;filePath&quot;&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;/data/applogs/xxx/&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;param&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;append&quot;&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;true&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;param&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;encoding&quot;&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;layout&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;org.apache.log4j.PatternLayout&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;param&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;ConversionPattern&quot;&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;%-d&amp;#123;yyyy-MM-dd HH:mm:ss&amp;#125; [%c]-[%t]-[%M]-[%L]-[%p] %m%n&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;layout&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;appender&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中，filePath 是日志文件夹路径。只要将日志输出在这个appender上，就能在调度控制中心远程查看业务执行的日志，如图所示：&lt;br&gt;&lt;img src=&quot;https://static.oschina.net/uploads/img/201605/19152223_gHux.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;要详细了解云调度中心ferrari的实现源码，请关注本博客，后续开源会在这里同步更新，或请邮件联系本人tengkai.yuan@dianping.com，谢谢!&lt;/p&gt;
&lt;h3 id=&quot;u53C2_u8003_u6587_u6863&quot;&gt;&lt;a href=&quot;#u53C2_u8003_u6587_u6863&quot; class=&quot;headerlink&quot; title=&quot;参考文档&quot;&gt;&lt;/a&gt;参考文档&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/davidwang456/p/4205237.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/davidwang456/p/4205237.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.ibm.com/developerworks/cn/opensource/os-cn-quartz/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.ibm.com/developerworks/cn/opensource/os-cn-quartz/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.quartz-scheduler.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.quartz-scheduler.org/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;云调度中心，本身不执行任何业务代码，只负责管理各个任务的调度，进而将调度与任务执行解耦，方便调度中心自身的升级维护。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>分布式异步调度框架Tiger</title>
    <link href="https://github.com/w4c101/2016/05/19/tengkai/tiger/"/>
    <id>https://github.com/w4c101/2016/05/19/tengkai/tiger/</id>
    <published>2016-05-19T06:07:59.000Z</published>
    <updated>2016-05-19T06:30:16.052Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;tiger&lt;/code&gt;是一种分布式异步调度框架，偏重于执行层面，同一种任务可以由多台机器同时执行，并能保证一条任务不被重复执行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;u80CC_u666F&quot;&gt;&lt;a href=&quot;#u80CC_u666F&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在后台，有很多业务场景需要定时处理一个任务，或在某件事情发生后处理一个任务。&lt;/p&gt;
&lt;p&gt;比如，dw团队后台数据同步时，一般会每天凌晨某个时间点跑一次数据同步任务。这样的业务场景1(定时处理任务)，很适合quartz来处理，或点评内部的taurus平台。&lt;/p&gt;
&lt;p&gt;有另外一种业务场景2(某个事件发生后触发处理任务)，比如你在12306上购买火车票提交订单后，系统会提示你在30分钟内完成支付，不然订单会被取消。针对这个情况，用quartz的定时任务方案也容易解决，只要开发一个quartz任务a每隔一段时间（比如每分钟）去轮询订单表，进行订单支付状态判断，如果未支付且时间已经超过30分钟，则将订单取消。&lt;/p&gt;
&lt;p&gt;但是，如果12306有个新的功能，希望对购买且支付成功的乘客，在列车开车前1小时进行短信提醒，那按quartz的做法，就是再开发一个任务b去轮询订单信息表，对已支付的订单，且列车发车时间距当前时间小于1小时的，进行短信发送提醒。如果类似的附加任务越来越多，每次都需要开发一个定时任务去跑，任务就会变得越来越臃肿，越来越难以统一管理。而且，当任务数很多，一台机器处理不过来，需要多台机器同时处理时，任务的重复消费问题也开始体现出来。&lt;/p&gt;
&lt;p&gt;为了解决上述问题，我们针对［业务场景2:&lt;strong&gt;一件事情发生后需要触发另一个事情&lt;/strong&gt;］的情况进行了抽象处理，提出一种&lt;strong&gt;基于事件驱动的分布式异步调度架构&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;u8BBE_u8BA1_u5B9E_u73B0_u539F_u7406&quot;&gt;&lt;a href=&quot;#u8BBE_u8BA1_u5B9E_u73B0_u539F_u7406&quot; class=&quot;headerlink&quot; title=&quot;设计实现原理&quot;&gt;&lt;/a&gt;设计实现原理&lt;/h2&gt;&lt;p&gt;&lt;code&gt;tiger&lt;/code&gt;是一种分布式异步调度框架，偏重于执行层面，同一种任务可以由多台机器同时执行，并能保证一条任务不被重复执行。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;tiger&lt;/code&gt;的设计目标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于事件驱动，一件事情发生后能指定下一个要做的任务，且能指定什么时候执行；&lt;/li&gt;
&lt;li&gt;高容错性，一个任务如果处理失败由任务本身来决定是否需要重新执行；&lt;/li&gt;
&lt;li&gt;集群环境下，同一个任务保证只执行一次，不被重复执行；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基于上述目标，&lt;code&gt;tiger&lt;/code&gt;主要有以下三部分组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;zk注册管理：用于管理应用机器的在线情况，进而对机器可执行的任务节点进行自适应分配，保证一个任务同一时间只会被一台机器消费；&lt;/li&gt;
&lt;li&gt;事件调度管理：用于每隔一定时间触发一次任务执行，并监听任务执行器的配置情况，一旦发生变化，即停止任务执行，重新设置后再触发任务执行；&lt;/li&gt;
&lt;li&gt;任务执行管理：用于管理本机所分配到的执行器节点，进而进行任务节点捞取、任务过滤等，并对任务的执行结果进行处理； &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;tiger的类结构如图：&lt;br&gt;&lt;img src=&quot;http://o7d9mhc6g.bkt.clouddn.com/image2016-5-16%2017-57-2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;实现难点考虑：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每一个任务的业务特性不一样，如何定义统一的业务参数；&lt;/li&gt;
&lt;li&gt;线上有多台机器，如何保证一个任务只会被一台机器执行；&lt;/li&gt;
&lt;li&gt;机器扩容或缩减时，在线的各个机器如何自适应分配各自能执行的任务，并保证不重复执行同一个任务；&lt;/li&gt;
&lt;li&gt;针对业务参数，任务表的数据结构单独定义一个业务参数字段，约定为json格式；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;针对多台机器同时处理任务的情况，在任务生成时通过hash计算得到虚拟节点node，再由任务机器选择虚拟节点执行，这样能保证一个任务只会被其中一台任务机器执行。如图所示：&lt;br&gt;&lt;img src=&quot;http://o7d9mhc6g.bkt.clouddn.com/image2016-5-16%2017-24-0.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;当一个任务task0过来时，根据hash取模计算得到该任务由虚拟节点v0处理，而tiger应用任务机器m0正好负责虚拟节点v0,v1的任务处理，这样task0就由任务机器m0处理，而不会被m1,m2处理。例举结婚商户通合同处理的一个任务contractHandler，如下图：&lt;br&gt;&lt;img src=&quot;http://o7d9mhc6g.bkt.clouddn.com/image2016-5-16%2017-28-27.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;当机器扩容或缩减时，为了能让在线的任务机器自适应分配可以处理的任务节点，引入zookeeper，任务机器一启动就注册到zk集群，进而做到任务机器对虚拟节点任务处理的自适应管理，如图所示：&lt;br&gt;&lt;img src=&quot;http://o7d9mhc6g.bkt.clouddn.com/image2016-5-16%2017-31-42.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;比如，当机器1挂掉时，zookeeper就会通知到机器2、3，此时虚拟节点就会重新分配，机器2负责node:0,1,2，机器3负责node:3,4,5，保证即使机器1挂掉的情况下，落在虚拟节点0,1上的任务也能被快速处理，避免任务堆积。&lt;/p&gt;
&lt;p&gt;到此为止，所述的任务执行基本都是并行处理的，业务上，也有任务需要按时间顺序串行处理的情况。&lt;/p&gt;
&lt;p&gt;如结婚商户通的合同上下线处理，原合同的到期下线时间： 2015-08-31 23:59:59，此时在这个时间点会执行一条合同任务a进行下线；&lt;/p&gt;
&lt;p&gt;由于该商户与点评合作很好，所以续签了一份新的合同，上线时间： 2015-09-01 00:00:00，这个时间会执行一条合同任务b将其上线；&lt;/p&gt;
&lt;p&gt;由于tiger默认一次性会获取200条任务，并交给线程池并发处理，此时任务a和b会同时被执行，由于多线程不保证时间顺序，可能导致任务b先执行完，然后任务a再执行。那么业务上，该商户明明续签了，但系统还是对其进行了下线（以最后一次执行为准）。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，tiger的任务执行策略支持并行和串行两种策略，默认为并行处理。如图：&lt;br&gt;&lt;img src=&quot;http://o7d9mhc6g.bkt.clouddn.com/image2016-5-16%2017-50-58.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果期望某个任务按串行处理，那么需要在任务实现类里加上一个注解：@ExecuteType(AnnotationConstants.Executor.CHAIN)，比如婚宴的商户通合同处理按串行执行：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;annotation&quot;&gt;@ExecuteType&lt;/span&gt;(AnnotationConstants.Executor.CHAIN)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ChainTestHandler&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;DispatchHandler&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;annotation&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; DispatchResult &lt;span class=&quot;title&quot;&gt;invoke&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(DispatchParam param)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       Long taskId =  param.getTaskId();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       String jsonStr = param.getBizParameter();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       Map&amp;lt;String, String&amp;gt; paramMap = (Map&amp;lt;String, String&amp;gt;) JSON.parse(jsonStr);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;tiger_u4F7F_u7528_u8BF4_u660E&quot;&gt;&lt;a href=&quot;#tiger_u4F7F_u7528_u8BF4_u660E&quot; class=&quot;headerlink&quot; title=&quot;tiger使用说明&quot;&gt;&lt;/a&gt;tiger使用说明&lt;/h2&gt;&lt;p&gt;回归到背景里提到的业务场景2，如果让tiger来处理，就会很方便。用户提交生成订单，此时插入一条［订单取消任务］，并指定执行时间30分钟后；用户订单支付成功后，此时插入一条［短信提醒任务］，并指定执行时间开车前1小时。在订单取消任务里判断订单是否已支付，如果已经支付成功，那么无需处理并返回，如果订单尚未支付，则执行订单取消逻辑；在短信提醒任务里，判断该订单状态是否有效（如果退款或改签），如果有效则发送短信提醒。&lt;br&gt;tiger适合任何的&lt;strong&gt;一件事情发生后需要触发另一个事情&lt;/strong&gt;的业务场景。&lt;/p&gt;
&lt;p&gt;具体tiger的使用说明请前往公司code系统上搜索wed-tiger项目查看readme，或者联系本作者tengkai.yuan@dianping.com。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;tiger&lt;/code&gt;是一种分布式异步调度框架，偏重于执行层面，同一种任务可以由多台机器同时执行，并能保证一条任务不被重复执行。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>&quot;嫁了APP&quot; React Native 摸索之路</title>
    <link href="https://github.com/w4c101/2016/05/18/perry/jiale-rn/"/>
    <id>https://github.com/w4c101/2016/05/18/perry/jiale-rn/</id>
    <published>2016-05-18T09:16:00.000Z</published>
    <updated>2016-05-19T06:07:08.744Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;程序不过是梦，&lt;br&gt;生于无形无象的禅中，&lt;br&gt;我们只是那做梦的人。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;u540D_u8BCD_u91CA_u4E49&quot;&gt;&lt;a href=&quot;#u540D_u8BCD_u91CA_u4E49&quot; class=&quot;headerlink&quot; title=&quot;名词释义&quot;&gt;&lt;/a&gt;名词释义&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;RN：React Native&lt;/li&gt;
&lt;li&gt;嫁了：嫁了App，由美团点评结婚团队倾力打造，专注于提供最in的结婚咨询~&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;u5199_u5728_u524D_u9762&quot;&gt;&lt;a href=&quot;#u5199_u5728_u524D_u9762&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;经过一段时间的摸索，“嫁了”全面使用RN已经具备一些环境与条件。RN能给我们带来什么？我们为什么要选择RN？&lt;br&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;快速需求迭代，省去Apple及Android渠道审核时间&lt;/li&gt;
&lt;li&gt;线上即时Bug Fix&lt;/li&gt;
&lt;li&gt;试错成本大大降低&lt;/li&gt;
&lt;li&gt;人力成本降低&lt;/li&gt;
&lt;li&gt;APP端学习成本降低&lt;/li&gt;
&lt;li&gt;性能不错，甚至有些优化不逊于Native&lt;/li&gt;
&lt;li&gt;coder不必刻意关注性能的优化，只需负责好业务与逻辑&lt;/li&gt;
&lt;li&gt;nmpjs.com上丰富的RN第三方库&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不知道什么时候Apple就审核不过了&lt;/li&gt;
&lt;li&gt;对iOS老手机(iphone4 &amp;amp; iphone4s)适配的不太理想&lt;/li&gt;
&lt;li&gt;iOS JS调用Native Promise方式似乎不太稳定&lt;/li&gt;
&lt;li&gt;Android jsc 不支持x64&lt;/li&gt;
&lt;li&gt;系统要求：Android 4.1以上 &amp;amp;&amp;amp; iOS 7.0以上&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;RN_u4E0ENative_u7684_u6027_u80FD_u5BF9_u6BD4&quot;&gt;&lt;a href=&quot;#RN_u4E0ENative_u7684_u6027_u80FD_u5BF9_u6BD4&quot; class=&quot;headerlink&quot; title=&quot;RN与Native的性能对比&quot;&gt;&lt;/a&gt;RN与Native的性能对比&lt;/h2&gt;&lt;p&gt;为了比较RN与Native的性能，我们使用RN完成了“嫁了”的首页编写，并从帧率、内存、CPU、过度绘制这四个方面，与现有的Native页面进行对比，结果如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;iOS：&lt;/strong&gt;&lt;br&gt;我们先来看看IOS的数据：&lt;br&gt;&lt;img src=&quot;http://o7d9mhc6g.bkt.clouddn.com/image2016-5-6%2016-47-54.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://o7d9mhc6g.bkt.clouddn.com/image2016-5-6%2016-47-6.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;从图中的数据上来看，RN的帧率始终接近60FPS，而Naitve的帧率相比于RN表现的略差。CPU的使用率RN比Native相比较高，但较为平稳。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Android：&lt;/strong&gt;&lt;br&gt;我们再来看看Android的数据：&lt;br&gt;&lt;img src=&quot;http://o7d9mhc6g.bkt.clouddn.com/image2016-5-6%2016-53-6.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://o7d9mhc6g.bkt.clouddn.com/image2016-5-6%2016-52-14.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;从图中可以看出，Android的GPU使用，RN基本低于60FPS的16ms刷新基准线以下，而Naitve的页面相对刷新时间较长，会偶尔超过30ms，这可能导致至少会掉2帧，造成用户视觉卡顿。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o7d9mhc6g.bkt.clouddn.com/image2016-5-6%2016-56-53.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://o7d9mhc6g.bkt.clouddn.com/image2016-5-6%2016-58-38.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;从图中可以看出，RN的过度绘制显然比Native好很多，由于“嫁了”首页动画效果，阴影效果比较多，也影响了Native的过度绘制的区域。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o7d9mhc6g.bkt.clouddn.com/image2016-5-6%2017-2-17.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://o7d9mhc6g.bkt.clouddn.com/image2016-5-6%2017-0-52.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;从图中可以看出，RN的CPU使用率比Native会高一些，但相对较为平稳。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结论：&lt;/strong&gt;&lt;br&gt;RN在几个性能指标上表现的都很不错，而且我在使用RN写“嫁了”首页的时候，并没有刻意的去关注这些性能指标，而且Facebook的官方文档上，也有关于性能的一些优化建议，这使得程序员可以非常轻松的书写代码，并且只关注页面展示与业务逻辑。So，放心大胆的上吧~&lt;/p&gt;
&lt;h2 id=&quot;u201C_u5AC1_u4E86_u201D_u6574_u4F53_u6846_u67B6&quot;&gt;&lt;a href=&quot;#u201C_u5AC1_u4E86_u201D_u6574_u4F53_u6846_u67B6&quot; class=&quot;headerlink&quot; title=&quot;“嫁了”整体框架&quot;&gt;&lt;/a&gt;“嫁了”整体框架&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://o7d9mhc6g.bkt.clouddn.com/image2016-5-6%2017-14-37.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MAPI Fetch&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MAPI的支持已经成为“嫁了”是否能全面使用RN的重大突破点（点评App现有MAPI使用的是自定义数据结构，并且有序列化及加解密过程）。&lt;/li&gt;
&lt;li&gt;MAPI兼容Web请求，返回JSON数据。&lt;/li&gt;
&lt;li&gt;MAPI安全性问题：采用Https，为了保护数据不被串改，我们依赖TLS，这依然靠强大的IT在支持。&lt;/li&gt;
&lt;li&gt;Cache：在未联网时，也能获取本地Cache的数据，这是区别web与native的关键所在，至少能在弱网络的情况下，返回一些Cache的数据，保持良好的用户体验。&lt;/li&gt;
&lt;li&gt;Fetch，我们依靠它在js中获取数据，它很强大，强大到很有可能会覆灭Ajax，&lt;a href=&quot;https://fetch.spec.whatwg.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Fetch API&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;RN_u7684_u4E00_u4E9B_u5DE5_u5177&quot;&gt;&lt;a href=&quot;#RN_u7684_u4E00_u4E9B_u5DE5_u5177&quot; class=&quot;headerlink&quot; title=&quot;RN的一些工具&quot;&gt;&lt;/a&gt;RN的一些工具&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;开发工具：&lt;/strong&gt;&lt;br&gt;Atom：可以安装Nuclide，react-native自动补全，css自动转换等插件包。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码检测：&lt;/strong&gt;&lt;br&gt;eslint：我们使用它来确保代码风格的一致性，代码的严格检测。&lt;/p&gt;
&lt;h2 id=&quot;u540E_u7EED_u5173_u6CE8&quot;&gt;&lt;a href=&quot;#u540E_u7EED_u5173_u6CE8&quot; class=&quot;headerlink&quot; title=&quot;后续关注&quot;&gt;&lt;/a&gt;后续关注&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Crash捕获&lt;/li&gt;
&lt;li&gt;RN源码深入理解&lt;/li&gt;
&lt;li&gt;RN集成sqlite&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;u53C2_u8003_u8D44_u6599&quot;&gt;&lt;a href=&quot;#u53C2_u8003_u8D44_u6599&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://facebook.github.io/react-native/docs/getting-started.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://facebook.github.io/react-native/docs/getting-started.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://facebook.github.io/react/docs/getting-started.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://facebook.github.io/react/docs/getting-started.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://css-tricks.com/snippets/css/a-guide-to-flexbox/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://css-tricks.com/snippets/css/a-guide-to-flexbox/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://fetch.spec.whatwg.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://fetch.spec.whatwg.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://eslint.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://eslint.org/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;程序不过是梦，&lt;br&gt;生于无形无象的禅中，&lt;br&gt;我们只是那做梦的人。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
