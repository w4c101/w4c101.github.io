<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>w4c101</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/w4c101/"/>
  <updated>2016-06-01T06:27:16.734Z</updated>
  <id>https://github.com/w4c101/</id>
  
  <author>
    <name>w4c101</name>
    <email>perry.du.cn@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基于quartz的云调度中心实现</title>
    <link href="https://github.com/w4c101/2016/05/31/tengkai/%E5%9F%BA%E4%BA%8Equartz%E7%9A%84%E4%BA%91%E8%B0%83%E5%BA%A6%E4%B8%AD%E5%BF%83%E5%AE%9E%E7%8E%B0/"/>
    <id>https://github.com/w4c101/2016/05/31/tengkai/基于quartz的云调度中心实现/</id>
    <published>2016-06-01T03:45:44.000Z</published>
    <updated>2016-06-01T06:27:16.734Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;云调度中心，本身不执行任何业务代码，只负责管理各个任务的调度，进而将调度与任务执行解耦，方便调度中心自身的升级维护。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;u80CC_u666F&quot;&gt;&lt;a href=&quot;#u80CC_u666F&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;作为业务开发人员，会经常需要写一个定时任务。目前，写定时任务应用最广泛最成熟的方案是OpenSymphony开源组织在任务调度领域的一个开源项目quartz，比如要写一个定时数据同步任务，在完成quartz的相关配置后，只需要写一个jobBean_A就能基于quartz完成调度；如果要再开发一个任务，那么再写一个jobBean_B。&lt;/p&gt;
&lt;p&gt;这样做的方式有一个地方不是很好，quartz调度与job业务耦合在一起，当任务数量越来越多，甚至达到成千上万个，对于项目本身的维护也是一个挺大的挑战。这时，会考虑将quartz任务项目拆分出来，但这样每一个任务工程都需要依赖quartz，不方便统一调度管理。为了能&lt;code&gt;统一管理调度任务&lt;/code&gt;，又能将&lt;code&gt;调度和job业务分离&lt;/code&gt;，我们提出&lt;code&gt;云调度方案&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;u67B6_u6784_u8BBE_u8BA1&quot;&gt;&lt;a href=&quot;#u67B6_u6784_u8BBE_u8BA1&quot; class=&quot;headerlink&quot; title=&quot;架构设计&quot;&gt;&lt;/a&gt;架构设计&lt;/h3&gt;&lt;p&gt;云调度中心ferrari的设计目标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调度中心本身不执行任何业务代码，只负责管理各个任务。这样的好处是，调度中心与业务job解耦，方便调度中心自身的升级维护；&lt;/li&gt;
&lt;li&gt;job无需关心调度中心的内部逻辑，只需关注自身的job业务逻辑，让写一个job像写一个web action一样方便。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基于上述初衷，我们提出的云调度中心设计方案，如图：&lt;br&gt;&lt;img src=&quot;https://static.oschina.net/uploads/img/201605/19150048_dmyG.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;总共分为三层：调度控制层，调度接入层，业务层。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;调度控制层，基于quartz实现，主要用于管理任务调度信息，如调度job的类名、方法名、方法入参、job地址、job执行时间等；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;调度接入层，主要用于接收调度控制中心的调度指令（如执行、终止任务命令），并根据接收到的任务信息（类名、方法名、入参）进行反射调用相应的任务类；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;业务层，这里主要用于实现job逻辑；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这样，要开发一个任务，基本不用关心调度控制层和接入层的逻辑，只需在业务层实现任务逻辑即可。任务开发完后，在调度控制中心新增一个调度任务信息，便可接收调度中心的调度。&lt;/p&gt;
&lt;h3 id=&quot;u5B9E_u73B0_u65B9_u6848&quot;&gt;&lt;a href=&quot;#u5B9E_u73B0_u65B9_u6848&quot; class=&quot;headerlink&quot; title=&quot;实现方案&quot;&gt;&lt;/a&gt;实现方案&lt;/h3&gt;&lt;p&gt;云调度中心的实现是基于quartz，所以对quartz必须有个清楚的理解。&lt;/p&gt;
&lt;p&gt;Quartz任务调度的核心元素是scheduler(调度器)，trigger(触发器，用于定义调度时间规则) 和 job(任务)，其中 trigger 和 job 是任务调度的元数据，scheduler 是实际执行调度的控制器。quartz内部的调度原理可以查看后面列举的参考文档，这里具体讲讲使用quartz的几个注意点。&lt;/p&gt;
&lt;h4 id=&quot;u7EBF_u7A0B_u6C60_u914D_u7F6E&quot;&gt;&lt;a href=&quot;#u7EBF_u7A0B_u6C60_u914D_u7F6E&quot; class=&quot;headerlink&quot; title=&quot;线程池配置&quot;&gt;&lt;/a&gt;线程池配置&lt;/h4&gt;&lt;p&gt;quartz.properties里的线程池配置：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#Configure ThreadPool&amp;#10;org.quartz.threadPool.class: org.quartz.simpl.SimpleThreadPool&amp;#10;org.quartz.threadPool.threadCount: 15&amp;#10;org.quartz.threadPool.threadPriority: 5&amp;#10;org.quartz.threadPool.threadsInheritContextClassLoaderOfInitializingThread: true&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Quartz 中自带了一个线程池的实现SimpleThreadPool，并通过threadCount来设置最大并发数，一般设置在10～50比较合适。&lt;/p&gt;
&lt;h4 id=&quot;misfire_u7B56_u7565&quot;&gt;&lt;a href=&quot;#misfire_u7B56_u7565&quot; class=&quot;headerlink&quot; title=&quot;misfire策略&quot;&gt;&lt;/a&gt;misfire策略&lt;/h4&gt;&lt;p&gt;misfire，即错过的，指本来应该被执行但实际没有被执行的任务调度，一般来说引起misfire的情况有以下4种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调度控制中心因为某些原因被重启。在系统关闭到重新启动之间的一段时间里，可能有些任务会被 misfire；&lt;/li&gt;
&lt;li&gt;Trigger 被暂停（suspend）的一段时间里，有些任务可能会被 misfire；&lt;/li&gt;
&lt;li&gt;线程池中所有线程都被占用，导致任务无法被触发执行，造成 misfire；&lt;/li&gt;
&lt;li&gt;有状态任务在下次触发时间到达时，上次执行还没有结束（无状态任务没有这种情况）；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;quartz对misfire的产生有个时间条件，超过这个设定的时间则认为是misfire，配置如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#Misfire&amp;#10;org.quartz.jobStore.misfireThreshold: 120000 #120&amp;#31186;&amp;#10;org.quartz.jobStore.maxMisfiresToHandleAtATime: 1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;为了处理 misfired job，Quartz 中为 trigger 定义了处理策略，主要有下面两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;MISFIRE_INSTRUCTION_FIRE_ONCE_NOW：针对 misfired job 马上执行一次；&lt;/li&gt;
&lt;li&gt;MISFIRE_INSTRUCTION_DO_NOTHING：忽略 misfired job，等待下次触发；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ferrari使用的是第2种策略：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CronScheduleBuilder cronScheduleBuilder = CronScheduleBuilder.cronSchedule(cronExpression).withMisfireHandlingInstructionDoNothing();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;u8C03_u5EA6_u96C6_u7FA4_u8BBE_u7F6E&quot;&gt;&lt;a href=&quot;#u8C03_u5EA6_u96C6_u7FA4_u8BBE_u7F6E&quot; class=&quot;headerlink&quot; title=&quot;调度集群设置&quot;&gt;&lt;/a&gt;调度集群设置&lt;/h4&gt;&lt;p&gt;Quartz 中的 trigger 和 job 需要存储下来才能被使用，有两种存储方式：内存和数据库。如果将调度信息存储在内存，那么只要quartz应用重启，这些信息就会丢失，所以在生产环境中，一般都用数据库存储的方式，配置如下：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#Configure JobStore for RAM&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#org.quartz.jobStore.class: org.quartz.simpl.RAMJobStore&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#for cluster&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;org.quartz.jobStore.tablePrefix = XXX_&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;org.quartz.jobStore.class: org.quartz.impl.jdbcjobstore.JobStoreTX &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;org.quartz.jobStore.isClustered: &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;org.quartz.jobStore.clusterCheckinInterval: &lt;span class=&quot;number&quot;&gt;20000&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;jobStore设置为jdbcjobstore.JobStoreTX即代表数据库存储方式，由于quartz集群是通过数据表来实现并发锁控制，所以需要设置集群的节点检查轮训时间clusterCheckinInterval，这里设置为20s。&lt;/p&gt;
&lt;h4 id=&quot;u8C03_u5EA6_u5668_u914D_u7F6E&quot;&gt;&lt;a href=&quot;#u8C03_u5EA6_u5668_u914D_u7F6E&quot; class=&quot;headerlink&quot; title=&quot;调度器配置&quot;&gt;&lt;/a&gt;调度器配置&lt;/h4&gt;&lt;p&gt;spring对quartz进行了整合，这里采用基于spring的quartz配置，如下：&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&amp;lt;!-- 默认 lazy-init=&quot;false&quot;spring-context-support version: 3.2.14.RELEASE quartz version:2.2.2--&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;bean&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;quartzScheduler&quot;&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;org.springframework.scheduling.quartz.SchedulerFactoryBean&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;property&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;dataSource&quot;&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;ref&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;dataSource&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&amp;lt;!-- 设置自动启动 --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;property&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;autoStartup&quot;&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;true&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&amp;lt;!--必须的，QuartzScheduler 延时启动，应用启动完后 QuartzScheduler 再启动 --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;property&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;startupDelay&quot;&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;20&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&amp;lt;!--需要overwrite已经存在的job，如果需要动态的修改已经存在的job，就需要设置为true，否则会以数据库中已经存在的为准--&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;property&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;overwriteExistingJobs&quot;&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;true&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;property&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;applicationContextSchedulerContextKey&quot;&lt;/span&gt;  &lt;span class=&quot;attribute&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;applicationContextKey&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;property&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;configLocation&quot;&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;classpath:quartz.properties&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;bean&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;quartz_u4EFB_u52A1_u5F00_u53D1&quot;&gt;&lt;a href=&quot;#quartz_u4EFB_u52A1_u5F00_u53D1&quot; class=&quot;headerlink&quot; title=&quot;quartz任务开发&quot;&gt;&lt;/a&gt;quartz任务开发&lt;/h4&gt;&lt;p&gt;基于云调度中心ferrari的架构，在调度控制中心层，我们只要开发一个quartzJobBean。在这个jobBean中，基于ferrari协议将需要执行的类名、方法名、入参、任务机器地址等信息封装成一个request，然后发送请求（ferrari用的是http请求）到任务目标机器。&lt;/p&gt;
&lt;p&gt;在业务层，任务机器接收到调度控制中心的指令，解析出任务信息，便交给任务执行线程池，任务执行线程通过反射调用目标任务类进行执行。作为业务层，无需基于quartz做任何开发，只需开发一个普通的类（称为任务类），然后将任务信息配置到调度控制中心，便可实现调度。&lt;/p&gt;
&lt;h3 id=&quot;ferrari_u63A5_u5165_u8BF4_u660E&quot;&gt;&lt;a href=&quot;#ferrari_u63A5_u5165_u8BF4_u660E&quot; class=&quot;headerlink&quot; title=&quot;ferrari接入说明&quot;&gt;&lt;/a&gt;ferrari接入说明&lt;/h3&gt;&lt;h4 id=&quot;maven_u4F9D_u8D56&quot;&gt;&lt;a href=&quot;#maven_u4F9D_u8D56&quot; class=&quot;headerlink&quot; title=&quot;maven依赖&quot;&gt;&lt;/a&gt;maven依赖&lt;/h4&gt;&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;com.dianping&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;ferrari-core&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;1.2.4&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;web-xml_u914D_u7F6Eservlet_u5165_u53E3&quot;&gt;&lt;a href=&quot;#web-xml_u914D_u7F6Eservlet_u5165_u53E3&quot; class=&quot;headerlink&quot; title=&quot;web.xml配置servlet入口&quot;&gt;&lt;/a&gt;web.xml配置servlet入口&lt;/h4&gt;&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;servlet&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;servlet-name&lt;/span&gt;&amp;gt;&lt;/span&gt;FerrariServlet&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;servlet-name&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;servlet-class&lt;/span&gt;&amp;gt;&lt;/span&gt;com.cip.ferrari.core.FerrariDirectServlet&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;servlet-class&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;load-on-startup&lt;/span&gt;&amp;gt;&lt;/span&gt;1&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;load-on-startup&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;servlet&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;servlet-mapping&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;servlet-name&lt;/span&gt;&amp;gt;&lt;/span&gt;FerrariServlet&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;servlet-name&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;url-pattern&lt;/span&gt;&amp;gt;&lt;/span&gt;/xxx/*&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;url-pattern&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;servlet-mapping&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;u5F00_u59CB_u5199_u4F60_u7684_u4EFB_u52A1_u7C7B_u53CA_u65B9_u6CD5_uFF0C_u7C7B_u540D_u3001_u65B9_u6CD5_u3001_u5165_u53C2_u5728_u65B0_u589E_u4EFB_u52A1_u65F6_u914D_u7F6E&quot;&gt;&lt;a href=&quot;#u5F00_u59CB_u5199_u4F60_u7684_u4EFB_u52A1_u7C7B_u53CA_u65B9_u6CD5_uFF0C_u7C7B_u540D_u3001_u65B9_u6CD5_u3001_u5165_u53C2_u5728_u65B0_u589E_u4EFB_u52A1_u65F6_u914D_u7F6E&quot; class=&quot;headerlink&quot; title=&quot;开始写你的任务类及方法，类名、方法、入参在新增任务时配置&quot;&gt;&lt;/a&gt;开始写你的任务类及方法，类名、方法、入参在新增任务时配置&lt;/h4&gt;&lt;p&gt;ferrari新增任务界面：&lt;br&gt;&lt;img src=&quot;https://static.oschina.net/uploads/img/201605/19152010_9IrQ.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;u4E91_u8C03_u5EA6_u4E2D_u5FC3_u65E5_u5FD7_u63A5_u5165&quot;&gt;&lt;a href=&quot;#u4E91_u8C03_u5EA6_u4E2D_u5FC3_u65E5_u5FD7_u63A5_u5165&quot; class=&quot;headerlink&quot; title=&quot;云调度中心日志接入&quot;&gt;&lt;/a&gt;云调度中心日志接入&lt;/h4&gt;&lt;p&gt;由于job任务不在调度中心执行，而是有另外的job服务机器执行，所以要看业务日志代码，必须登录对应的业务机器。如果job很多，又散落在各个机器，那么要查看job运行日志，效率就会比较低。为了方便日志查看，ferrari提供了日志接入方案，在log4j.xml中增加一个append配置：&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;appender&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;FERRARI&quot;&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;com.cip.ferrari.core.log.FerrariFileAppender&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;param&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;filePath&quot;&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;/data/applogs/xxx/&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;param&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;append&quot;&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;true&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;param&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;encoding&quot;&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;layout&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;org.apache.log4j.PatternLayout&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;param&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;ConversionPattern&quot;&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;%-d&amp;#123;yyyy-MM-dd HH:mm:ss&amp;#125; [%c]-[%t]-[%M]-[%L]-[%p] %m%n&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;layout&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;appender&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中，filePath 是日志文件夹路径。只要将日志输出在这个appender上，就能在调度控制中心远程查看业务执行的日志，如图所示：&lt;br&gt;&lt;img src=&quot;https://static.oschina.net/uploads/img/201605/19152223_gHux.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;要详细了解云调度中心ferrari的实现源码，请关注本博客，后续开源会在这里同步更新，或请邮件联系本人tengkai.yuan@dianping.com，谢谢!&lt;/p&gt;
&lt;h3 id=&quot;u53C2_u8003_u6587_u6863&quot;&gt;&lt;a href=&quot;#u53C2_u8003_u6587_u6863&quot; class=&quot;headerlink&quot; title=&quot;参考文档&quot;&gt;&lt;/a&gt;参考文档&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/davidwang456/p/4205237.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/davidwang456/p/4205237.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.ibm.com/developerworks/cn/opensource/os-cn-quartz/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.ibm.com/developerworks/cn/opensource/os-cn-quartz/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.quartz-scheduler.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.quartz-scheduler.org/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;云调度中心，本身不执行任何业务代码，只负责管理各个任务的调度，进而将调度与任务执行解耦，方便调度中心自身的升级维护。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>分布式异步调度框架Tiger</title>
    <link href="https://github.com/w4c101/2016/05/19/tengkai/tiger/"/>
    <id>https://github.com/w4c101/2016/05/19/tengkai/tiger/</id>
    <published>2016-05-19T06:07:59.000Z</published>
    <updated>2016-05-19T06:30:16.052Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;tiger&lt;/code&gt;是一种分布式异步调度框架，偏重于执行层面，同一种任务可以由多台机器同时执行，并能保证一条任务不被重复执行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;u80CC_u666F&quot;&gt;&lt;a href=&quot;#u80CC_u666F&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在后台，有很多业务场景需要定时处理一个任务，或在某件事情发生后处理一个任务。&lt;/p&gt;
&lt;p&gt;比如，dw团队后台数据同步时，一般会每天凌晨某个时间点跑一次数据同步任务。这样的业务场景1(定时处理任务)，很适合quartz来处理，或点评内部的taurus平台。&lt;/p&gt;
&lt;p&gt;有另外一种业务场景2(某个事件发生后触发处理任务)，比如你在12306上购买火车票提交订单后，系统会提示你在30分钟内完成支付，不然订单会被取消。针对这个情况，用quartz的定时任务方案也容易解决，只要开发一个quartz任务a每隔一段时间（比如每分钟）去轮询订单表，进行订单支付状态判断，如果未支付且时间已经超过30分钟，则将订单取消。&lt;/p&gt;
&lt;p&gt;但是，如果12306有个新的功能，希望对购买且支付成功的乘客，在列车开车前1小时进行短信提醒，那按quartz的做法，就是再开发一个任务b去轮询订单信息表，对已支付的订单，且列车发车时间距当前时间小于1小时的，进行短信发送提醒。如果类似的附加任务越来越多，每次都需要开发一个定时任务去跑，任务就会变得越来越臃肿，越来越难以统一管理。而且，当任务数很多，一台机器处理不过来，需要多台机器同时处理时，任务的重复消费问题也开始体现出来。&lt;/p&gt;
&lt;p&gt;为了解决上述问题，我们针对［业务场景2:&lt;strong&gt;一件事情发生后需要触发另一个事情&lt;/strong&gt;］的情况进行了抽象处理，提出一种&lt;strong&gt;基于事件驱动的分布式异步调度架构&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;u8BBE_u8BA1_u5B9E_u73B0_u539F_u7406&quot;&gt;&lt;a href=&quot;#u8BBE_u8BA1_u5B9E_u73B0_u539F_u7406&quot; class=&quot;headerlink&quot; title=&quot;设计实现原理&quot;&gt;&lt;/a&gt;设计实现原理&lt;/h2&gt;&lt;p&gt;&lt;code&gt;tiger&lt;/code&gt;是一种分布式异步调度框架，偏重于执行层面，同一种任务可以由多台机器同时执行，并能保证一条任务不被重复执行。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;tiger&lt;/code&gt;的设计目标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于事件驱动，一件事情发生后能指定下一个要做的任务，且能指定什么时候执行；&lt;/li&gt;
&lt;li&gt;高容错性，一个任务如果处理失败由任务本身来决定是否需要重新执行；&lt;/li&gt;
&lt;li&gt;集群环境下，同一个任务保证只执行一次，不被重复执行；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基于上述目标，&lt;code&gt;tiger&lt;/code&gt;主要有以下三部分组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;zk注册管理：用于管理应用机器的在线情况，进而对机器可执行的任务节点进行自适应分配，保证一个任务同一时间只会被一台机器消费；&lt;/li&gt;
&lt;li&gt;事件调度管理：用于每隔一定时间触发一次任务执行，并监听任务执行器的配置情况，一旦发生变化，即停止任务执行，重新设置后再触发任务执行；&lt;/li&gt;
&lt;li&gt;任务执行管理：用于管理本机所分配到的执行器节点，进而进行任务节点捞取、任务过滤等，并对任务的执行结果进行处理； &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;tiger的类结构如图：&lt;br&gt;&lt;img src=&quot;http://o7d9mhc6g.bkt.clouddn.com/image2016-5-16%2017-57-2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;实现难点考虑：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每一个任务的业务特性不一样，如何定义统一的业务参数；&lt;/li&gt;
&lt;li&gt;线上有多台机器，如何保证一个任务只会被一台机器执行；&lt;/li&gt;
&lt;li&gt;机器扩容或缩减时，在线的各个机器如何自适应分配各自能执行的任务，并保证不重复执行同一个任务；&lt;/li&gt;
&lt;li&gt;针对业务参数，任务表的数据结构单独定义一个业务参数字段，约定为json格式；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;针对多台机器同时处理任务的情况，在任务生成时通过hash计算得到虚拟节点node，再由任务机器选择虚拟节点执行，这样能保证一个任务只会被其中一台任务机器执行。如图所示：&lt;br&gt;&lt;img src=&quot;http://o7d9mhc6g.bkt.clouddn.com/image2016-5-16%2017-24-0.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;当一个任务task0过来时，根据hash取模计算得到该任务由虚拟节点v0处理，而tiger应用任务机器m0正好负责虚拟节点v0,v1的任务处理，这样task0就由任务机器m0处理，而不会被m1,m2处理。例举结婚商户通合同处理的一个任务contractHandler，如下图：&lt;br&gt;&lt;img src=&quot;http://o7d9mhc6g.bkt.clouddn.com/image2016-5-16%2017-28-27.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;当机器扩容或缩减时，为了能让在线的任务机器自适应分配可以处理的任务节点，引入zookeeper，任务机器一启动就注册到zk集群，进而做到任务机器对虚拟节点任务处理的自适应管理，如图所示：&lt;br&gt;&lt;img src=&quot;http://o7d9mhc6g.bkt.clouddn.com/image2016-5-16%2017-31-42.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;比如，当机器1挂掉时，zookeeper就会通知到机器2、3，此时虚拟节点就会重新分配，机器2负责node:0,1,2，机器3负责node:3,4,5，保证即使机器1挂掉的情况下，落在虚拟节点0,1上的任务也能被快速处理，避免任务堆积。&lt;/p&gt;
&lt;p&gt;到此为止，所述的任务执行基本都是并行处理的，业务上，也有任务需要按时间顺序串行处理的情况。&lt;/p&gt;
&lt;p&gt;如结婚商户通的合同上下线处理，原合同的到期下线时间： 2015-08-31 23:59:59，此时在这个时间点会执行一条合同任务a进行下线；&lt;/p&gt;
&lt;p&gt;由于该商户与点评合作很好，所以续签了一份新的合同，上线时间： 2015-09-01 00:00:00，这个时间会执行一条合同任务b将其上线；&lt;/p&gt;
&lt;p&gt;由于tiger默认一次性会获取200条任务，并交给线程池并发处理，此时任务a和b会同时被执行，由于多线程不保证时间顺序，可能导致任务b先执行完，然后任务a再执行。那么业务上，该商户明明续签了，但系统还是对其进行了下线（以最后一次执行为准）。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，tiger的任务执行策略支持并行和串行两种策略，默认为并行处理。如图：&lt;br&gt;&lt;img src=&quot;http://o7d9mhc6g.bkt.clouddn.com/image2016-5-16%2017-50-58.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果期望某个任务按串行处理，那么需要在任务实现类里加上一个注解：@ExecuteType(AnnotationConstants.Executor.CHAIN)，比如婚宴的商户通合同处理按串行执行：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;annotation&quot;&gt;@ExecuteType&lt;/span&gt;(AnnotationConstants.Executor.CHAIN)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ChainTestHandler&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;DispatchHandler&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;annotation&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; DispatchResult &lt;span class=&quot;title&quot;&gt;invoke&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(DispatchParam param)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       Long taskId =  param.getTaskId();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       String jsonStr = param.getBizParameter();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       Map&amp;lt;String, String&amp;gt; paramMap = (Map&amp;lt;String, String&amp;gt;) JSON.parse(jsonStr);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;tiger_u4F7F_u7528_u8BF4_u660E&quot;&gt;&lt;a href=&quot;#tiger_u4F7F_u7528_u8BF4_u660E&quot; class=&quot;headerlink&quot; title=&quot;tiger使用说明&quot;&gt;&lt;/a&gt;tiger使用说明&lt;/h2&gt;&lt;p&gt;回归到背景里提到的业务场景2，如果让tiger来处理，就会很方便。用户提交生成订单，此时插入一条［订单取消任务］，并指定执行时间30分钟后；用户订单支付成功后，此时插入一条［短信提醒任务］，并指定执行时间开车前1小时。在订单取消任务里判断订单是否已支付，如果已经支付成功，那么无需处理并返回，如果订单尚未支付，则执行订单取消逻辑；在短信提醒任务里，判断该订单状态是否有效（如果退款或改签），如果有效则发送短信提醒。&lt;br&gt;tiger适合任何的&lt;strong&gt;一件事情发生后需要触发另一个事情&lt;/strong&gt;的业务场景。&lt;/p&gt;
&lt;p&gt;具体tiger的使用说明请前往公司code系统上搜索wed-tiger项目查看readme，或者联系本作者tengkai.yuan@dianping.com。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;tiger&lt;/code&gt;是一种分布式异步调度框架，偏重于执行层面，同一种任务可以由多台机器同时执行，并能保证一条任务不被重复执行。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>&quot;嫁了APP&quot; React Native 摸索之路</title>
    <link href="https://github.com/w4c101/2016/05/18/perry/jiale-rn/"/>
    <id>https://github.com/w4c101/2016/05/18/perry/jiale-rn/</id>
    <published>2016-05-18T09:16:00.000Z</published>
    <updated>2016-05-19T06:07:08.744Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;程序不过是梦，&lt;br&gt;生于无形无象的禅中，&lt;br&gt;我们只是那做梦的人。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;u540D_u8BCD_u91CA_u4E49&quot;&gt;&lt;a href=&quot;#u540D_u8BCD_u91CA_u4E49&quot; class=&quot;headerlink&quot; title=&quot;名词释义&quot;&gt;&lt;/a&gt;名词释义&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;RN：React Native&lt;/li&gt;
&lt;li&gt;嫁了：嫁了App，由美团点评结婚团队倾力打造，专注于提供最in的结婚咨询~&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;u5199_u5728_u524D_u9762&quot;&gt;&lt;a href=&quot;#u5199_u5728_u524D_u9762&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;经过一段时间的摸索，“嫁了”全面使用RN已经具备一些环境与条件。RN能给我们带来什么？我们为什么要选择RN？&lt;br&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;快速需求迭代，省去Apple及Android渠道审核时间&lt;/li&gt;
&lt;li&gt;线上即时Bug Fix&lt;/li&gt;
&lt;li&gt;试错成本大大降低&lt;/li&gt;
&lt;li&gt;人力成本降低&lt;/li&gt;
&lt;li&gt;APP端学习成本降低&lt;/li&gt;
&lt;li&gt;性能不错，甚至有些优化不逊于Native&lt;/li&gt;
&lt;li&gt;coder不必刻意关注性能的优化，只需负责好业务与逻辑&lt;/li&gt;
&lt;li&gt;nmpjs.com上丰富的RN第三方库&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不知道什么时候Apple就审核不过了&lt;/li&gt;
&lt;li&gt;对iOS老手机(iphone4 &amp;amp; iphone4s)适配的不太理想&lt;/li&gt;
&lt;li&gt;iOS JS调用Native Promise方式似乎不太稳定&lt;/li&gt;
&lt;li&gt;Android jsc 不支持x64&lt;/li&gt;
&lt;li&gt;系统要求：Android 4.1以上 &amp;amp;&amp;amp; iOS 7.0以上&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;RN_u4E0ENative_u7684_u6027_u80FD_u5BF9_u6BD4&quot;&gt;&lt;a href=&quot;#RN_u4E0ENative_u7684_u6027_u80FD_u5BF9_u6BD4&quot; class=&quot;headerlink&quot; title=&quot;RN与Native的性能对比&quot;&gt;&lt;/a&gt;RN与Native的性能对比&lt;/h2&gt;&lt;p&gt;为了比较RN与Native的性能，我们使用RN完成了“嫁了”的首页编写，并从帧率、内存、CPU、过度绘制这四个方面，与现有的Native页面进行对比，结果如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;iOS：&lt;/strong&gt;&lt;br&gt;我们先来看看IOS的数据：&lt;br&gt;&lt;img src=&quot;http://o7d9mhc6g.bkt.clouddn.com/image2016-5-6%2016-47-54.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://o7d9mhc6g.bkt.clouddn.com/image2016-5-6%2016-47-6.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;从图中的数据上来看，RN的帧率始终接近60FPS，而Naitve的帧率相比于RN表现的略差。CPU的使用率RN比Native相比较高，但较为平稳。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Android：&lt;/strong&gt;&lt;br&gt;我们再来看看Android的数据：&lt;br&gt;&lt;img src=&quot;http://o7d9mhc6g.bkt.clouddn.com/image2016-5-6%2016-53-6.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://o7d9mhc6g.bkt.clouddn.com/image2016-5-6%2016-52-14.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;从图中可以看出，Android的GPU使用，RN基本低于60FPS的16ms刷新基准线以下，而Naitve的页面相对刷新时间较长，会偶尔超过30ms，这可能导致至少会掉2帧，造成用户视觉卡顿。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o7d9mhc6g.bkt.clouddn.com/image2016-5-6%2016-56-53.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://o7d9mhc6g.bkt.clouddn.com/image2016-5-6%2016-58-38.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;从图中可以看出，RN的过度绘制显然比Native好很多，由于“嫁了”首页动画效果，阴影效果比较多，也影响了Native的过度绘制的区域。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o7d9mhc6g.bkt.clouddn.com/image2016-5-6%2017-2-17.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://o7d9mhc6g.bkt.clouddn.com/image2016-5-6%2017-0-52.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;从图中可以看出，RN的CPU使用率比Native会高一些，但相对较为平稳。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结论：&lt;/strong&gt;&lt;br&gt;RN在几个性能指标上表现的都很不错，而且我在使用RN写“嫁了”首页的时候，并没有刻意的去关注这些性能指标，而且Facebook的官方文档上，也有关于性能的一些优化建议，这使得程序员可以非常轻松的书写代码，并且只关注页面展示与业务逻辑。So，放心大胆的上吧~&lt;/p&gt;
&lt;h2 id=&quot;u201C_u5AC1_u4E86_u201D_u6574_u4F53_u6846_u67B6&quot;&gt;&lt;a href=&quot;#u201C_u5AC1_u4E86_u201D_u6574_u4F53_u6846_u67B6&quot; class=&quot;headerlink&quot; title=&quot;“嫁了”整体框架&quot;&gt;&lt;/a&gt;“嫁了”整体框架&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://o7d9mhc6g.bkt.clouddn.com/image2016-5-6%2017-14-37.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MAPI Fetch&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MAPI的支持已经成为“嫁了”是否能全面使用RN的重大突破点（点评App现有MAPI使用的是自定义数据结构，并且有序列化及加解密过程）。&lt;/li&gt;
&lt;li&gt;MAPI兼容Web请求，返回JSON数据。&lt;/li&gt;
&lt;li&gt;MAPI安全性问题：采用Https，为了保护数据不被串改，我们依赖TLS，这依然靠强大的IT在支持。&lt;/li&gt;
&lt;li&gt;Cache：在未联网时，也能获取本地Cache的数据，这是区别web与native的关键所在，至少能在弱网络的情况下，返回一些Cache的数据，保持良好的用户体验。&lt;/li&gt;
&lt;li&gt;Fetch，我们依靠它在js中获取数据，它很强大，强大到很有可能会覆灭Ajax，&lt;a href=&quot;https://fetch.spec.whatwg.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Fetch API&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;RN_u7684_u4E00_u4E9B_u5DE5_u5177&quot;&gt;&lt;a href=&quot;#RN_u7684_u4E00_u4E9B_u5DE5_u5177&quot; class=&quot;headerlink&quot; title=&quot;RN的一些工具&quot;&gt;&lt;/a&gt;RN的一些工具&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;开发工具：&lt;/strong&gt;&lt;br&gt;Atom：可以安装Nuclide，react-native自动补全，css自动转换等插件包。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码检测：&lt;/strong&gt;&lt;br&gt;eslint：我们使用它来确保代码风格的一致性，代码的严格检测。&lt;/p&gt;
&lt;h2 id=&quot;u540E_u7EED_u5173_u6CE8&quot;&gt;&lt;a href=&quot;#u540E_u7EED_u5173_u6CE8&quot; class=&quot;headerlink&quot; title=&quot;后续关注&quot;&gt;&lt;/a&gt;后续关注&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Crash捕获&lt;/li&gt;
&lt;li&gt;RN源码深入理解&lt;/li&gt;
&lt;li&gt;RN集成sqlite&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;u53C2_u8003_u8D44_u6599&quot;&gt;&lt;a href=&quot;#u53C2_u8003_u8D44_u6599&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://facebook.github.io/react-native/docs/getting-started.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://facebook.github.io/react-native/docs/getting-started.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://facebook.github.io/react/docs/getting-started.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://facebook.github.io/react/docs/getting-started.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://css-tricks.com/snippets/css/a-guide-to-flexbox/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://css-tricks.com/snippets/css/a-guide-to-flexbox/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://fetch.spec.whatwg.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://fetch.spec.whatwg.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://eslint.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://eslint.org/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;程序不过是梦，&lt;br&gt;生于无形无象的禅中，&lt;br&gt;我们只是那做梦的人。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
