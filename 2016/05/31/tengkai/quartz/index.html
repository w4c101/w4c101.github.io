<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 基于quartz的云调度中心实现 · w4c101</title><meta name="description" content="基于quartz的云调度中心实现 - w4c101"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/header.jpg"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/header.jpg"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/w4c101" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">基于quartz的云调度中心实现</h1><div class="post-info">2016年5月31日</div><div class="post-content"><blockquote>
<p>云调度中心，本身不执行任何业务代码，只负责管理各个任务的调度，进而将调度与任务执行解耦，方便调度中心自身的升级维护。</p>
</blockquote>
<a id="more"></a>
<h3 id="u80CC_u666F"><a href="#u80CC_u666F" class="headerlink" title="背景"></a>背景</h3><p>作为业务开发人员，会经常需要写一个定时任务。目前，写定时任务应用最广泛最成熟的方案是OpenSymphony开源组织在任务调度领域的一个开源项目quartz，比如要写一个定时数据同步任务，在完成quartz的相关配置后，只需要写一个jobBean_A就能基于quartz完成调度；如果要再开发一个任务，那么再写一个jobBean_B。</p>
<p>这样做的方式有一个地方不是很好，quartz调度与job业务耦合在一起，当任务数量越来越多，甚至达到成千上万个，对于项目本身的维护也是一个挺大的挑战。这时，会考虑将quartz任务项目拆分出来，但这样每一个任务工程都需要依赖quartz，不方便统一调度管理。为了能<code>统一管理调度任务</code>，又能将<code>调度和job业务分离</code>，我们提出<code>云调度方案</code>。</p>
<h3 id="u67B6_u6784_u8BBE_u8BA1"><a href="#u67B6_u6784_u8BBE_u8BA1" class="headerlink" title="架构设计"></a>架构设计</h3><p>云调度中心ferrari的设计目标：</p>
<ul>
<li>调度中心本身不执行任何业务代码，只负责管理各个任务。这样的好处是，调度中心与业务job解耦，方便调度中心自身的升级维护；</li>
<li>job无需关心调度中心的内部逻辑，只需关注自身的job业务逻辑，让写一个job像写一个web action一样方便。</li>
</ul>
<p>基于上述初衷，我们提出的云调度中心设计方案，如图：<br><img src="https://static.oschina.net/uploads/img/201605/19150048_dmyG.png" alt=""></p>
<p>总共分为三层：调度控制层，调度接入层，业务层。</p>
<ol>
<li><p>调度控制层，基于quartz实现，主要用于管理任务调度信息，如调度job的类名、方法名、方法入参、job地址、job执行时间等；</p>
</li>
<li><p>调度接入层，主要用于接收调度控制中心的调度指令（如执行、终止任务命令），并根据接收到的任务信息（类名、方法名、入参）进行反射调用相应的任务类；</p>
</li>
<li><p>业务层，这里主要用于实现job逻辑；</p>
</li>
</ol>
<p>这样，要开发一个任务，基本不用关心调度控制层和接入层的逻辑，只需在业务层实现任务逻辑即可。任务开发完后，在调度控制中心新增一个调度任务信息，便可接收调度中心的调度。</p>
<h3 id="u5B9E_u73B0_u65B9_u6848"><a href="#u5B9E_u73B0_u65B9_u6848" class="headerlink" title="实现方案"></a>实现方案</h3><p>云调度中心的实现是基于quartz，所以对quartz必须有个清楚的理解。</p>
<p>Quartz任务调度的核心元素是scheduler(调度器)，trigger(触发器，用于定义调度时间规则) 和 job(任务)，其中 trigger 和 job 是任务调度的元数据，scheduler 是实际执行调度的控制器。quartz内部的调度原理可以查看后面列举的参考文档，这里具体讲讲使用quartz的几个注意点。</p>
<h4 id="u7EBF_u7A0B_u6C60_u914D_u7F6E"><a href="#u7EBF_u7A0B_u6C60_u914D_u7F6E" class="headerlink" title="线程池配置"></a>线程池配置</h4><p>quartz.properties里的线程池配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#Configure ThreadPool&#10;org.quartz.threadPool.class: org.quartz.simpl.SimpleThreadPool&#10;org.quartz.threadPool.threadCount: 15&#10;org.quartz.threadPool.threadPriority: 5&#10;org.quartz.threadPool.threadsInheritContextClassLoaderOfInitializingThread: true</span><br></pre></td></tr></table></figure></p>
<p>Quartz 中自带了一个线程池的实现SimpleThreadPool，并通过threadCount来设置最大并发数，一般设置在10～50比较合适。</p>
<h4 id="misfire_u7B56_u7565"><a href="#misfire_u7B56_u7565" class="headerlink" title="misfire策略"></a>misfire策略</h4><p>misfire，即错过的，指本来应该被执行但实际没有被执行的任务调度，一般来说引起misfire的情况有以下4种：</p>
<ul>
<li>调度控制中心因为某些原因被重启。在系统关闭到重新启动之间的一段时间里，可能有些任务会被 misfire；</li>
<li>Trigger 被暂停（suspend）的一段时间里，有些任务可能会被 misfire；</li>
<li>线程池中所有线程都被占用，导致任务无法被触发执行，造成 misfire；</li>
<li>有状态任务在下次触发时间到达时，上次执行还没有结束（无状态任务没有这种情况）；</li>
</ul>
<p>quartz对misfire的产生有个时间条件，超过这个设定的时间则认为是misfire，配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#Misfire&#10;org.quartz.jobStore.misfireThreshold: 120000 #120&#31186;&#10;org.quartz.jobStore.maxMisfiresToHandleAtATime: 1</span><br></pre></td></tr></table></figure>
<p>为了处理 misfired job，Quartz 中为 trigger 定义了处理策略，主要有下面两种：</p>
<ol>
<li>MISFIRE_INSTRUCTION_FIRE_ONCE_NOW：针对 misfired job 马上执行一次；</li>
<li>MISFIRE_INSTRUCTION_DO_NOTHING：忽略 misfired job，等待下次触发；</li>
</ol>
<p>ferrari使用的是第2种策略：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CronScheduleBuilder cronScheduleBuilder = CronScheduleBuilder.cronSchedule(cronExpression).withMisfireHandlingInstructionDoNothing();</span><br></pre></td></tr></table></figure>
<h4 id="u8C03_u5EA6_u96C6_u7FA4_u8BBE_u7F6E"><a href="#u8C03_u5EA6_u96C6_u7FA4_u8BBE_u7F6E" class="headerlink" title="调度集群设置"></a>调度集群设置</h4><p>Quartz 中的 trigger 和 job 需要存储下来才能被使用，有两种存储方式：内存和数据库。如果将调度信息存储在内存，那么只要quartz应用重启，这些信息就会丢失，所以在生产环境中，一般都用数据库存储的方式，配置如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Configure JobStore for RAM</span></span><br><span class="line"><span class="comment">#org.quartz.jobStore.class: org.quartz.simpl.RAMJobStore</span></span><br><span class="line"><span class="comment">#for cluster</span></span><br><span class="line">org.quartz.jobStore.tablePrefix = XXX_</span><br><span class="line">org.quartz.jobStore.class: org.quartz.impl.jdbcjobstore.JobStoreTX </span><br><span class="line">org.quartz.jobStore.isClustered: <span class="literal">true</span></span><br><span class="line">org.quartz.jobStore.clusterCheckinInterval: <span class="number">20000</span></span><br></pre></td></tr></table></figure>
<p>jobStore设置为jdbcjobstore.JobStoreTX即代表数据库存储方式，由于quartz集群是通过数据表来实现并发锁控制，所以需要设置集群的节点检查轮训时间clusterCheckinInterval，这里设置为20s。</p>
<h4 id="u8C03_u5EA6_u5668_u914D_u7F6E"><a href="#u8C03_u5EA6_u5668_u914D_u7F6E" class="headerlink" title="调度器配置"></a>调度器配置</h4><p>spring对quartz进行了整合，这里采用基于spring的quartz配置，如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 默认 lazy-init="false"spring-context-support version: 3.2.14.RELEASE quartz version:2.2.2--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"quartzScheduler"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.scheduling.quartz.SchedulerFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"dataSource"</span> <span class="attribute">ref</span>=<span class="value">"dataSource"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置自动启动 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"autoStartup"</span> <span class="attribute">value</span>=<span class="value">"true"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--必须的，QuartzScheduler 延时启动，应用启动完后 QuartzScheduler 再启动 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"startupDelay"</span> <span class="attribute">value</span>=<span class="value">"20"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--需要overwrite已经存在的job，如果需要动态的修改已经存在的job，就需要设置为true，否则会以数据库中已经存在的为准--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"overwriteExistingJobs"</span> <span class="attribute">value</span>=<span class="value">"true"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"applicationContextSchedulerContextKey"</span>  <span class="attribute">value</span>=<span class="value">"applicationContextKey"</span> /&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"configLocation"</span> <span class="attribute">value</span>=<span class="value">"classpath:quartz.properties"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="quartz_u4EFB_u52A1_u5F00_u53D1"><a href="#quartz_u4EFB_u52A1_u5F00_u53D1" class="headerlink" title="quartz任务开发"></a>quartz任务开发</h4><p>基于云调度中心ferrari的架构，在调度控制中心层，我们只要开发一个quartzJobBean。在这个jobBean中，基于ferrari协议将需要执行的类名、方法名、入参、任务机器地址等信息封装成一个request，然后发送请求（ferrari用的是http请求）到任务目标机器。</p>
<p>在业务层，任务机器接收到调度控制中心的指令，解析出任务信息，便交给任务执行线程池，任务执行线程通过反射调用目标任务类进行执行。作为业务层，无需基于quartz做任何开发，只需开发一个普通的类（称为任务类），然后将任务信息配置到调度控制中心，便可实现调度。</p>
<h3 id="ferrari_u63A5_u5165_u8BF4_u660E"><a href="#ferrari_u63A5_u5165_u8BF4_u660E" class="headerlink" title="ferrari接入说明"></a>ferrari接入说明</h3><h4 id="maven_u4F9D_u8D56"><a href="#maven_u4F9D_u8D56" class="headerlink" title="maven依赖"></a>maven依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>com.dianping<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>ferrari-core<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.2.4<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="web-xml_u914D_u7F6Eservlet_u5165_u53E3"><a href="#web-xml_u914D_u7F6Eservlet_u5165_u53E3" class="headerlink" title="web.xml配置servlet入口"></a>web.xml配置servlet入口</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>FerrariServlet<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">servlet-class</span>&gt;</span>com.cip.ferrari.core.FerrariDirectServlet<span class="tag">&lt;/<span class="title">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="title">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>FerrariServlet<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/xxx/*<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="u5F00_u59CB_u5199_u4F60_u7684_u4EFB_u52A1_u7C7B_u53CA_u65B9_u6CD5_uFF0C_u7C7B_u540D_u3001_u65B9_u6CD5_u3001_u5165_u53C2_u5728_u65B0_u589E_u4EFB_u52A1_u65F6_u914D_u7F6E"><a href="#u5F00_u59CB_u5199_u4F60_u7684_u4EFB_u52A1_u7C7B_u53CA_u65B9_u6CD5_uFF0C_u7C7B_u540D_u3001_u65B9_u6CD5_u3001_u5165_u53C2_u5728_u65B0_u589E_u4EFB_u52A1_u65F6_u914D_u7F6E" class="headerlink" title="开始写你的任务类及方法，类名、方法、入参在新增任务时配置"></a>开始写你的任务类及方法，类名、方法、入参在新增任务时配置</h4><p>ferrari新增任务界面：<br><img src="https://static.oschina.net/uploads/img/201605/19152010_9IrQ.png" alt=""></p>
<h4 id="u4E91_u8C03_u5EA6_u4E2D_u5FC3_u65E5_u5FD7_u63A5_u5165"><a href="#u4E91_u8C03_u5EA6_u4E2D_u5FC3_u65E5_u5FD7_u63A5_u5165" class="headerlink" title="云调度中心日志接入"></a>云调度中心日志接入</h4><p>由于job任务不在调度中心执行，而是有另外的job服务机器执行，所以要看业务日志代码，必须登录对应的业务机器。如果job很多，又散落在各个机器，那么要查看job运行日志，效率就会比较低。为了方便日志查看，ferrari提供了日志接入方案，在log4j.xml中增加一个append配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">appender</span> <span class="attribute">name</span>=<span class="value">"FERRARI"</span> <span class="attribute">class</span>=<span class="value">"com.cip.ferrari.core.log.FerrariFileAppender"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"filePath"</span> <span class="attribute">value</span>=<span class="value">"/data/applogs/xxx/"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"append"</span> <span class="attribute">value</span>=<span class="value">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"encoding"</span> <span class="attribute">value</span>=<span class="value">"UTF-8"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">layout</span> <span class="attribute">class</span>=<span class="value">"org.apache.log4j.PatternLayout"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"ConversionPattern"</span> <span class="attribute">value</span>=<span class="value">"%-d&#123;yyyy-MM-dd HH:mm:ss&#125; [%c]-[%t]-[%M]-[%L]-[%p] %m%n"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">layout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">appender</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中，filePath 是日志文件夹路径。只要将日志输出在这个appender上，就能在调度控制中心远程查看业务执行的日志，如图所示：<br><img src="https://static.oschina.net/uploads/img/201605/19152223_gHux.png" alt=""><br>要详细了解云调度中心ferrari的实现源码，请关注本博客，后续开源会在这里同步更新，或请邮件联系本人tengkai.yuan@dianping.com，谢谢!</p>
<h3 id="u53C2_u8003_u6587_u6863"><a href="#u53C2_u8003_u6587_u6863" class="headerlink" title="参考文档"></a>参考文档</h3><ol>
<li><a href="http://www.cnblogs.com/davidwang456/p/4205237.html" target="_blank" rel="external">http://www.cnblogs.com/davidwang456/p/4205237.html</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-quartz/" target="_blank" rel="external">https://www.ibm.com/developerworks/cn/opensource/os-cn-quartz/</a></li>
<li><a href="http://www.quartz-scheduler.org/" target="_blank" rel="external">http://www.quartz-scheduler.org/</a></li>
</ol>
</div></article></div></section><footer><div class="paginator"><a href="/2016/06/24/xueli/xxl-job/" class="prev">上一篇</a><a href="/2016/05/19/tengkai/tiger/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2016 <a href="https://github.com/w4c101">w4c101</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-72551441-1",'auto');ga('send','pageview');</script></body></html>